// issuedDeviceRequestMapper.js - Request mapper for Issued Device Administration API

const logger = require("../../common/logger/logger.js");
const customerInfoConstants = require("../helper/customerInfoConstants.js");

const APP_CAT_ID = process.env.APP_CAT_ID;
const LOG_PREFIX = "issuedDeviceRequestMapper.js - ";

module.exports = {
    /**
     * Builds the request object for making the call to Issued Device Administration API.
     * @param {string} ecifId
     * @param {string} correlationId
     * @returns {object} request payload
     */
    getIssuedDeviceRequest: (ecifId, correlationId) => {
        logger.trace("In getIssuedDeviceRequest.....", correlationId);

        const requestPayload = {
            ecifID: ecifId,
            expandList: customerInfoConstants.IDA_EXPAND_LIST || "all",
            scope: customerInfoConstants.IDA_SCOPE || "default",
            businessCategory: [
                customerInfoConstants.IDA_BUSINESS_CATEGORY || "WEALTH"
            ],
            originatorData: {
                applicationCatalogueID: customerInfoConstants.APP_CAT_ID,
                country: customerInfoConstants.COUNTRY_CANADA,
                locationID: "192.168.0.0", // Static as per existing pattern
                locationType: "IP",
                channel: "web", 
                employeeUserID: "customerInfoService", // Service identifier
                employeeUserName: "customerInfoService",
                transitNumber: "000" // Default value
            }
        };

        logger.debugWithSanitize(
            requestPayload,
            LOG_PREFIX.concat("getIssuedDeviceRequest.requestPayload"),
            correlationId
        );

        logger.trace("Out getIssuedDeviceRequest.....", correlationId);
        return requestPayload;
    }
};












-----------------------------------------------------------------














// NEW FILE: /ida/issuedDeviceService.js
// Simple service following your existing patterns

const logger = require("../../common/logger/logger.js");
const ciConstants = require("../helper/customerInfoConstants.js");
const customerInfoErrorCodes = require("../helper/customerInfoErrorCodes.js");
const requestMapper = require("./issuedDeviceRequestMapper.js");
const responseMapper = require("../helper/customerInfoResponseMapper.js"); // Reuse existing
const axios = require("axios");
const crossAccountSSMParamHelper = require("../../common/util/aws/crossAccountSSMParamHelper.js");

const LOG_PREFIX = "issuedDeviceService.js - ";
const API_BASE_URL = process.env.ISSUED_DEVICE_ADMINISTRATION_BASE_URI || "https://api2-dev.bmogc.net";
const API_END_POINT = "/api/issued-device-administration/alias/ecif/get";
const APP_CAT_ID = process.env.APP_CAT_ID;
const API_TIMEOUT = process.env.BACKEND_API_TIMEOUT;

const getIssuedDeviceDetails = async (requestParams, correlationId, requestId) => {
    logger.trace(
        LOG_PREFIX.concat("In getIssuedDeviceDetails begins.. with requestId: ", requestId),
        correlationId
    );

    return new Promise(async function (resolve, reject) {
        const startTime = Date.now();
        const apiURL = API_BASE_URL + API_END_POINT;

        // For now, use same SSM pattern as other services - adjust role ARN as needed
        let deviceSSMParams;
        try {
            deviceSSMParams = await crossAccountSSMParamHelper.getCrossAccountSSMParams(
                ciConstants.CROSS_ACCOUNT_ROLE_ARN_CI_DEV2, // Adjust this as needed
                ciConstants.SSM_PARAM.SC_GET_ISSUED_DEVICE_API_KEY,
                ciConstants.SSM_PARAM.SC_GET_ISSUED_DEVICE_AWS_GW_ID,
                correlationId
            );
        } catch (error) {
            logger.error(
                LOG_PREFIX.concat("Error retrieving SSM params for device API"),
                error,
                correlationId
            );
            const errorResponse = responseMapper.mapErrorResponse(
                customerInfoErrorCodes.VENDOR_ERROR.INTERNAL_SERVER_ERROR.statusCode,
                customerInfoErrorCodes.VENDOR_ERROR.INTERNAL_SERVER_ERROR,
                correlationId
            );
            return reject(errorResponse);
        }

        const SC_DEVICE_AWS_KEY = deviceSSMParams[ciConstants.SSM_PARAM.SC_GET_ISSUED_DEVICE_API_KEY];
        const SC_DEVICE_AWS_GW_ID = deviceSSMParams[ciConstants.SSM_PARAM.SC_GET_ISSUED_DEVICE_AWS_GW_ID];

        const payload = requestMapper.getIssuedDeviceRequest(requestParams.ecifId, correlationId);

        logger.logBackendServiceRequest(
            LOG_PREFIX.concat("Device API REST API"),
            payload,
            correlationId
        );

        const headers = {
            "x-api-key": SC_DEVICE_AWS_KEY,
            "x-apigw-api-id": SC_DEVICE_AWS_GW_ID,
            "x-request-id": correlationId,
            "x-fapi-interaction-id": correlationId,
            "x-fapi-financial-id": ciConstants.X_FAPI_FINANCIAL_ID_BMO,
            "x-app-cat-id": APP_CAT_ID,
            "Content-Type": "application/json"
        };

        try {
            const response = await axios.post(apiURL, payload, {
                timeout: API_TIMEOUT,
                headers: headers
            });

            logger.info(
                LOG_PREFIX.concat("response.status: ", response.status),
                correlationId
            );

            logger.logBackendServiceResponse(
                LOG_PREFIX.concat("Device API REST API"),
                startTime,
                response.data,
                correlationId
            );

            if (response.status === 200) {
                return resolve(response.data);
            } else {
                return reject(response.data);
            }

        } catch (error) {
            logger.error(
                LOG_PREFIX.concat("Error calling device API"),
                error,
                correlationId
            );

            const errorResponse = responseMapper.mapErrorResponse(
                customerInfoErrorCodes.VENDOR_ERROR.INTERNAL_SERVER_ERROR.statusCode,
                customerInfoErrorCodes.VENDOR_ERROR.INTERNAL_SERVER_ERROR,
                correlationId
            );
            return reject(errorResponse);
        }
    });
};

--------------------------------------------------------
# Sample Data Flow - Existing Consent Logic

## **Input: JWT Token Sample**

```json
{
  "oid": "12345678901234567890",
  "client_id": "mobile-banking-app-v2",
  "iss": "https://auth.bmo.com",
  "aud": "customer-info-api",
  "exp": 1705123456,
  "iat": 1705119856
}
```

**Extracted Values:**
- `ecifId = "12345678901234567890"`
- `clientId = "mobile-banking-app-v2"`

---

## **STEP 1: Get Retail Consent Details**

### **Request to `retailConsentService.getRetailConsentDetails()`:**
```json
{
  "consentHistoryFilter": "ACTIVE",
  "userId": "12345678901234567890",
  "clientId": "mobile-banking-app-v2"
}
```

### **Response Sample (SUCCESS CASE):**
```json
{
  "permissions": [
    {
      "permissionId": "consent-abc123-def456",
      "permissionLastUpdateDate": "2024-01-15T10:30:00Z",
      "permissionStatus": "ACTIVE",
      "accountList": [
        {
          "accountId": "acc-12345",
          "accountType": "CHECKING",
          "permissions": ["READ", "BALANCE"]
        },
        {
          "accountId": "acc-67890", 
          "accountType": "SAVINGS",
          "permissions": ["READ", "BALANCE", "TRANSACTIONS"]
        }
      ],
      "permissionDefinitions": [
        {
          "permission": "Cust_Contact",
          "description": "Access to customer contact information"
        },
        {
          "permission": "Account_Basic", 
          "description": "Basic account information access"
        }
      ],
      "clientMetaData": {
        "scope": "account_basic customer_contact account_transactions",
        "clientName": "Mobile Banking App",
        "registrationDate": "2024-01-01T00:00:00Z"
      }
    }
  ]
}
```

### **Response Sample (NO PERMISSIONS CASE):**
```json
{
  "permissions": []
}
```

---

## **STEP 2: Check for Permissions**

### **Code Check:**
```javascript
if (!retailConsentResponse.permissions?.[0]) {
    return CUSTOMER_NOT_AUTHORIZED; // FAIL - No permissions exist
}
```

**Success**: `permissions[0]` exists  
**Failure**: Empty `permissions` array → Customer gets `CUSTOMER_NOT_AUTHORIZED`

---

## **STEP 3: `hasActiveConsentAndScopeMatched()` Function**

This function makes **two separate checks**:

### **3.1: `hasActiveConsent(accountList)`**

**Input:** `accountList` from step 1 response
```json
[
  {
    "accountId": "acc-12345",
    "accountType": "CHECKING", 
    "permissions": ["READ", "BALANCE"]
  },
  {
    "accountId": "acc-67890",
    "accountType": "SAVINGS",
    "permissions": ["READ", "BALANCE", "TRANSACTIONS"] 
  }
]
```

**Logic:** `accountList && accountList.length > 0`  
**Result:** `true` (has 2 accounts)

### **3.2: `isScopeMatched(retailConsent)`**

**Input:** Full retail consent from step 1  
**Target Pattern:** `"Cust_Contact"` (from `customerInfoConstants.CUSTOMER_CONSENT_SCOPE`)

**Permission Definitions Check:**
```json
"permissionDefinitions": [
  {
    "permission": "Cust_Contact", ← MATCHES!
    "description": "Access to customer contact information"
  },
  {
    "permission": "Account_Basic",
    "description": "Basic account information access" 
  }
]
```

**Logic:** Loop through `permissionDefinitions`, check if any `permission` matches `"Cust_Contact"`  
**Result:** `true` (found "Cust_Contact" match)

### **Combined Result:**
`hasActiveConsent = true AND isScopeMatched = true` → **PASS**

---

## **STEP 4: DR (Data Recipient) Scope Matching**

### **Function:** `isCustomerConsentedScopesAndDRRegisteredScopesMatched()`

### **Input Data:**
**Customer Consented Scopes** (from `permissionDefinitions`):
```json
[
  {"permission": "Cust_Contact"},
  {"permission": "Account_Basic"}
]
```

**Client Registered Scopes** (from `clientMetaData.scope`):
```json
"scope": "account_basic customer_contact account_transactions"
```
Split into: `["account_basic", "customer_contact", "account_transactions"]`

**FDX to ECIF Mapping** (from SSM):
```json
{
  "fdxToEcif": {
    "account_basic": "Account_Basic",
    "customer_contact": "Cust_Contact", 
    "account_transactions": "Account_Transactions"
  }
}
```

### **Matching Logic:**
```
Customer Scope 1: "Cust_Contact"
  - Check against client scope "account_basic" → fdxToEcif["account_basic"] = "Account_Basic" → NO MATCH
  - Check against client scope "customer_contact" → fdxToEcif["customer_contact"] = "Cust_Contact" → MATCH!
  - Check against client scope "account_transactions" → fdxToEcif["account_transactions"] = "Account_Transactions" → NO MATCH

Customer Scope 2: "Account_Basic"  
  - Check against client scope "account_basic" → fdxToEcif["account_basic"] = "Account_Basic" → MATCH!
  - Check against client scope "customer_contact" → fdxToEcif["customer_contact"] = "Cust_Contact" → NO MATCH
  - Check against client scope "account_transactions" → fdxToEcif["account_transactions"] = "Account_Transactions" → NO MATCH
```

**Results:**
- Customer consented scopes: 2
- Matched scopes: 2  
- **Match!** All customer scopes are covered by client registration

---

## **STEP 5A: SUCCESS CASE - Get Customer Profile**

If all checks pass, call `retrievePartyViewService.getCustomerProfileDetails()`

### **Sample Customer Profile Response:**
```json
{
  "person": {
    "personName": [
      {
        "nameUsageType": "1",
        "givenNameOne": "John",
        "givenNameTwo": "Michael", 
        "lastName": "Smith"
      }
    ],
    "partyAddress": [
      {
        "addressUsageType": "100000",
        "address": {
          "addressLineOne": "123 Main Street",
          "addressLineTwo": "Apt 4B",
          "city": "Toronto",
          "provinceStateTypeValue": "ON",
          "zipPostalCode": "M5V 3A8",
          "countryTypeCode": "CA"
        }
      }
    ],
    "partyContactMethod": [
      {
        "contactMethodUsageType": "100008",
        "contactMethod": {
          "contactMethodType": "2",
          "referenceNumber": "john.smith@email.com"
        }
      },
      {
        "contactMethodUsageType": "100000", 
        "contactMethod": {
          "contactMethodType": "1",
          "phoneNumber": {
            "phoneCountryCode": "1"
          },
          "referenceNumber": "416-555-0123"
        }
      }
    ]
  }
}
```

### **Final Response to Customer:**
```json
{
  "name": {
    "first": "John",
    "middle": "Michael",
    "last": "Smith"
  },
  "addresses": [
    {
      "line1": "123 Main Street",
      "line2": "Apt 4B", 
      "line3": "",
      "city": "Toronto",
      "region": "ON",
      "postalCode": "M5V 3A8",
      "country": "CA",
      "type": "HOME"
    }
  ],
  "email": ["john.smith@email.com"],
  "telephones": [
    {
      "country": "1",
      "number": "+416-555-0123",
      "type": "HOME"
    }
  ]
}
```

---

## **STEP 5B: FAILURE CASE - Scope Mismatch & Delete**

### **Scenario:** Customer has different scopes than client expects

**Customer Consented Scopes:**
```json
[{"permission": "Cust_Contact"}]
```

**Client Registered Scopes:**
```json
"scope": "account_basic account_transactions"
```

**Mapping Result:**
- Customer has: `"Cust_Contact"`
- Client needs: `"Account_Basic"` + `"Account_Transactions"`  
- **Mismatch!** Customer scope doesn't cover what client registered for

### **Delete Process Begins:**

#### **5B.1: Find IV User**

**Call to `retrievePartyIdentification.getCustomerIdentificationDetails()`:**
```json
{
  "originatorData": {
    "applicationCatalogueId": "3384",
    "country": "CAN"
  },
  "outputIdType": "OCIF",
  "identifier": {
    "id": "12345678901234567890",
    "type": "ECIF"
  }
}
```

**Response:**
```json
{
  "identifier": {
    "id": "OCIF98765432109876543210",
    "type": "OCIF"
  }
}
```

#### **5B.2: Get Credential Service Users**

**Call to `credentialService.getCustomerISAMCredentials()`:**
```json
["user123", "user456@ciam", "user789"]
```

#### **5B.3: Get User Grants**

For each IV user, call `isamService.getUserGrant()`:

**Sample Grant Response:**
```json
[
  {
    "id": "grant-xyz789",
    "clientId": "mobile-banking-app-v2",
    "scopes": ["account_basic", "customer_contact"],
    "status": "ACTIVE"
  },
  {
    "id": "grant-abc123", 
    "clientId": "different-client",
    "scopes": ["account_basic"],
    "status": "ACTIVE"
  }
]
```

**Match Found:** `grant-xyz789` matches `clientId = "mobile-banking-app-v2"`  
**Result:** `ivUser = "user456@ciam"`, `grantId = "grant-xyz789"`

#### **5B.4: Delete Consent**

**Delete Request Payload:**
```json
{
  "originatorData": {
    "applicationCatalogueId": "3384",
    "country": "ca"
  },
  "userId": "12345678901234567890",
  "iv-user": "user456@ciam",
  "permissions": [
    {
      "permissionId": "consent-abc123-def456",
      "permissionLastUpdateDate": "2024-01-15T10:30:00Z",
      "clientId": "mobile-banking-app-v2",
      "grantId": "grant-xyz789"
    }
  ]
}
```

**Expected Response:** `HTTP 204 No Content` (successful deletion)

**Final Result:** Customer gets `CUSTOMER_NOT_AUTHORIZED` error

---

## **SQS Event Sample**

### **Success Case:**
```json
{
  "customerId": "12345678901234567890",
  "clientId": "mobile-banking-app-v2", 
  "consentId": "consent-abc123-def456",
  "logRecStatus": "ACTIVE",
  "lastAccessedDate": "20240115",
  "fapiInteractionID": "correlation-id-12345"
}
```

### **With New Device API Fallback:**
```json
{
  "customerId": "12345678901234567890",
  "clientId": "mobile-banking-app-v2",
  "authMethod": "device_credential",
  "deviceUid": "57BD5EEB67D349B1838B2F5419B46446", 
  "fallbackReason": "scope_mismatch_deleted",
  "businessCategory": ["WEALTH-NESBITTBURNS"],
  "logRecStatus": "ACTIVE",
  "lastAccessedDate": "20240115",
  "fapiInteractionID": "correlation-id-12345"
}
```

This shows exactly how your current flow works with real data examples, and where the new device API would fit in as a fallback mechanism.

module.exports = {
    getIssuedDeviceDetails
};

----------------------------------



const stage = process.env.STAGE || "sandbox";
const region = process.env.REGION;
const regionShortCode = process.env.REGION_SHORT_CODE;
const environment = process.env.ENVIRONMENT;
const stageShortCode = process.env.STAGE_SHORT_CODE;
const SC_DLA_EVENT_SQS_STAGE = process.env.SC_DLA_EVENT_SQS_STAGE;

const rpvStage = process.env.RPV_STAGE;
const rpiStage = process.env.RPI_STAGE;
const tpaaStage = process.env.TPAA_STAGE;
const isdsStage = process.env.ISDS_STAGE || "dev"; // New stage for ISDS

const dev1AccountNumberSimple = process.env.DEV1_ACCOUNT_ID_SIMPLE;
const dev2AccountNumberSimple = process.env.DEV2_ACCOUNT_ID_SIMPLE;

const APP_CAT_ID = process.env.APP_CAT_ID;

module.exports = {
  STAGES: {
    Sandbox: "sandbox",
    Dev: "dev",
    sit2: "sit2",
    sit3: "sit3",
    sit4: "sit4",
    sit5: "sit5",
    sit6: "sit6",
    sit7: "sit7",
    sit8: "sit8",
    Perf: "perf1",
    Perf2: "perf2",
    Prod: "prd"
  },
  EXECUTION_MODE: "mock",
  RESULT_TYPE_STATUS_ACTIVE: "Active",
  LIGHTWEIGHT_INTERNAL: "lightweightInternal",
  COUNTRY_CANADA: "CAN",
  APP_CAT_ID: APP_CAT_ID,
  RPV_IDENTIFIER_TYPE_ECIF: "ECIF",
  RPI_OUTPUT_TYPE: "OCIF",
  RPV_PERSON_FILTER: ["person", "basic"],
  
  // ISDS Constants
  IDA_EXPAND_LIST: "all",
  IDA_SCOPE: "default",
  IDA_BUSINESS_CATEGORY: "WEALTH",
  
  RPV_ADDRESS_TYPE: {
    HOME: "100000",
    BUSINESS: "100001"
  },
  RPV_PERSON_NAME_USAGE_TYPE: {
    LEGAL: "1"
  },
  RPV_CONTACT_METHOD_TYPE: {
    PHONE: "1",
    EMAIL: "2"
  },
  TIMEZONE_EST: "Canada/Eastern",
  DATE_FORMAT: "YYYYMMDD",
  LAST_ACCESSED_DATE_FORMAT: "YYYY-MM-DD HH:mm:ss",
  STATUS_ACTIVE: "Active",
  
  CROSS_ACCOUNT_ROLE_ARN_CI_DEV1: `arn:aws:iam::${dev1AccountNumberSimple}:role/86836/pbbopbkcustomerinfoapilambda/CHS-OPB-${environment}-${region}-${stage}-opbk-ci-param-cross-acen-01e`,
  CROSS_ACCOUNT_ROLE_ARN_CI_DEV2: `arn:aws:iam::${dev2AccountNumberSimple}:role/86836/pbbopbkcustomerinfoapilambda/CHS-OPB-${environment}-${region}-${stage}-opbk-ci-param-cross-acon-zolo`,
  
  SYMCOR_TELEPHONE_TYPE: {
    BUSINESS: "BUSINESS",
    CELL: "CELL",
    FAX: "FAX",
    PAGER: "PAGER",
    TTYTDD: "TTY/TDD"
  },
  SYMCOR_ADDRESS_TYPE: {
    HOME: "HOME",
    BUSINESS: "BUSINESS"
  },
  RPV_TELEPHONE_TYPE: {
    HOME: "100000",
    BUSINESS: "100001",
    PERMANENT_BUSINESS_PRIMARY_PHONE: "100002",
    BUSINESS_PRIMARY_CELL_PHONE: "100005",
    FAX: {
      PRIMARY_RESIDENTIAL: "100112",
      PRIMARY_BUSINESS: "100116"
    },
    PAGER: {
      PRIMARY_RESIDENTIAL: "100113",
      PRIMARY_BUSINESS: "100117"
    },
    TTYTDD: {
      PRIMARY_RESIDENTIAL: "100114",
      PRIMARY_BUSINESS: "100118"
    }
  },
  RPV_EMAIL_TYPE: ["100008", "100009", "100148", "100149"],
  PARTY_TYPE: {
    RESIDENTIAL_PRIMARY: "p",
    BUSINESS_PRIMARY: "o"
  },
  CUSTOMER_CONSENT_SCOPE: "Cust_Contact",
  RC_USER_NOT_FOUND: "E100",
  RC_INVALID_CLIENT: "E101",
  SSM_PARAM: {
    SC_DATA_ACCESS_EVENT_QUEUE_URI: `/SCCG/DC-SymcorThirdPartyAccessArrangement/${SC_DLA_EVENT_SQS_STAGE}/CDK/SymcorThirdPartyAccessArrQueue/URI`,
    SC_GET_THIRD_PARTY_ACCESS_ARRANGEMENT_API_KEY: `/SCCG/DeploymentConfig/ThirdPartyAccessArrangement/SCCG-ThirdPartyAccessArrangement/ApiKey/${tpaaStage}/Value`,
    SC_GET_THIRD_PARTY_ACCESS_ARRANGEMENT_AWS_GW_ID: `/SCCG/SCCG-ThirdPartyAccessArrangement/CDK/APIGateway/Id`,
    SC_GET_RETRIEVE_PARTY_VIEW_API_KEY: `/SCCG/DeploymentConfig/RetrievePartyView/RetrievePartyView/ApiKey/${rpvStage}/Value`,
    SC_GET_RETRIEVE_PARTY_VIEW_AWS_GW_ID: `/SCCG/DC-RetrievePartyView/CDR/APIGateway/Id`,
    SC_GET_RETRIEVE_PARTY_IDENTIFICATION_API_KEY: `/SCCG/DeploymentConfig/PartyIdentity/SCCG-PartyIdentity/ApiKey/${rpiStage}/Value`,
    SC_GET_RETRIEVE_PARTY_IDENTIFICATION_AWS_GW_HOST: `/SCCG/DeploymentConfig/PartyIdentity/SCCG-PartyIdentity/API&GWHost`,
    
    // ISDS API SSM Parameters
    SC_GET_ISSUED_DEVICE_API_KEY: `/SCCG/DeploymentConfig/IssuedDevice/SCCG-IssuedDevice/ApiKey/${isdsStage}/Value`,
    SC_GET_ISSUED_DEVICE_AWS_GW_ID: `/SCCG/SCCG-IssuedDevice/CDK/APIGateway/Id`,
    
    MTLS_CERT_SECRET_NAME: `/CHS/DeploymentConfig/pbb-opbk-lambda/${environment}/${stage}/${regionShortCode}/cdk/mtls/cert/secret/name`,
    MTLS_KEY_SECRET_NAME: `/CHS/DeploymentConfig/pbb-opbk-lambda/${environment}/${stage}/${regionShortCode}/cdk/mtls/key/secret/name`,
    MTLS_KEY_PWD_SECRET_NAME: `/CHS/DeploymentConfig/pbb-opbk-lambda/${environment}/${stage}/${regionShortCode}/cdk/mtls/key/pwd/secret/name`,
    MTLS_WKP_SECRET_NAME: `/CHS/DeploymentConfig/pbb-opbk-lambda/${environment}/${stage}/${regionShortCode}/cdk/mtls/secret/wkp/name`,
    MTLS_CERT_CROSS_ACC_ROLE_SECRET_NAME: `/CHS/DeploymentConfig/pbb-opbk-lambda/${environment}/${stage}/${regionShortCode}/cdk/mtls/secret/wkp/crossaccount-role`
  },
  X_FAPI_FINANCIAL_ID_BMO: "001",
  CREDENTIAL_SERVICE_CHANNEL_URN: "urn:bmo:customer:channel:systems:retcan:banking:ocif",
  API_ENDPOINTS: {
    GET_PARTY_DETAILS_END_POINT: "/party-reference-data-directory/party-view/get",
    GET_RETAIL_CONSENTS_END_POINT: "/customer-access-entitlement/third-party-access-arrangement/permissions/get",
    DEL_RETAIL_CONSENT_END_POINT: "/customer-access-entitlement/third-party-access-arrangement/delete",
    SC_RPI_GET_OCIF_ID_END_POINT: "/party-data-management/identification/get",
    ISDS_CREDENTIAL_SERVICE_END_POINT: "/sys-isam/issued-device-administration/uids/get?ocifId=",
    ISAM_CUSTOMER_GRANT_SERVICE_END_POINT: "/issued-device-administration/oath-token/grants",
    // ISDS API Endpoint
    ISDS_GET_DEVICE_DETAILS_END_POINT: "/api/issued-device-administration/alias/ecif/get"
  }
};




----------------------------------------------------------------------------------------------------------
const logger = require("././common/logger/logger.js");
const ERRORCODES = require("./customerInfErrorCodes.js");
const LOG_PREFIX = "customerConsentDeleteUtil.js - ";
const retrievePartyIdentification = require("../rpi/retrievePartyIdentificationService.js");
const credentialService = require("../cs/credentialService.js");
const isamService = require("../isam/isamCustomerGrantsService.js");
const issuedDeviceService = require("../ida/issuedDeviceService.js"); // New ISDS service
const responseMapper = require("../helper/customerInfoResponseMapper.js");

/**
 * Original method to find IV User from credential service
 */
const findIVUser = async (args, requestParams, clientId, correlationId, requestId) => {
    return new Promise(async function (resolve, reject) {
        try {
            const ocifid = await retrievePartyIdentification.getCustomerIdentificationDetails(
                requestParams,
                correlationId,
                requestId
            );

            logger.info(
                LOG_PREFIX.concat("Retrieved the OCIF-ID from the RPI API: ", ocifid),
                correlationId
            );

            const ivUsers = await credentialService.getCustomerISAMCredentials(
                args,
                ocifid,
                correlationId,
                requestId
            );

            logger.info(
                LOG_PREFIX.concat(ivUsers.length, " ivUser(s) retrieved from the CredentialService."),
                correlationId
            );

            for (let ivUser of ivUsers) {
                if (!ivUser?.includes("@ciam")) {
                    ivUser = ivUser + "@ciam";
                }

                const grants = await isamService.getUserGrant(
                    args,
                    ivUser,
                    correlationId,
                    requestId
                );

                for (const grant of grants) {
                    if (grant.clientId === clientId) {
                        return resolve([ivUser, grant.id]);
                    }
                }
            }

            logger.error(
                LOG_PREFIX.concat(
                    ERRORCODES.INVALID_RESP_CS_API.code,
                    " ",
                    ERRORCODES.INVALID_RESP_CS_API.message,
                    " Not able to identify the matched iv-user"
                ),
                correlationId
            );

            const errorResponse = responseMapper.mapErrorResponse(
                ERRORCODES.VENDOR_ERROR.INTERNAL_SERVER_ERROR.code,
                ERRORCODES.VENDOR_ERROR.INTERNAL_SERVER_ERROR,
                correlationId
            );

            return reject(errorResponse);

        } catch (err) {
            logger.error(
                LOG_PREFIX.concat(
                    ERRORCODES.VENDOR_ERROR.INTERNAL_SERVER_ERROR.code,
                    " ",
                    ERRORCODES.VENDOR_ERROR.INTERNAL_SERVER_ERROR.message
                ),
                err,
                correlationId
            );

            const errorResponse = responseMapper.mapErrorResponse(
                ERRORCODES.VENDOR_ERROR.INTERNAL_SERVER_ERROR.code,
                ERRORCODES.VENDOR_ERROR.INTERNAL_SERVER_ERROR,
                correlationId
            );

            return reject(errorResponse);
        }
    });
};

/**
 * New method to find IV User from ISDS API
 */
const findIVUserFromISDS = async (args, requestParams, clientId, correlationId, requestId) => {
    return new Promise(async function (resolve, reject) {
        try {
            logger.info(
                LOG_PREFIX.concat("Calling ISDS API to get device details for ecifId: ", requestParams.ecifId),
                correlationId
            );

            // Call ISDS API to get device details
            const isdsResponse = await issuedDeviceService.getIssuedDeviceDetails(
                requestParams,
                correlationId,
                requestId
            );

            logger.infoWithSanitize(
                isdsResponse,
                LOG_PREFIX.concat("ISDS API response received: "),
                correlationId
            );

            // Extract UID from ISDS response
            const uid = isdsResponse?.credentialIdentityInfo?.uid;
            if (!uid) {
                logger.error(
                    LOG_PREFIX.concat("No UID found in ISDS response"),
                    correlationId
                );
                const errorResponse = responseMapper.mapErrorResponse(
                    ERRORCODES.VENDOR_ERROR.INTERNAL_SERVER_ERROR.code,
                    ERRORCODES.VENDOR_ERROR.INTERNAL_SERVER_ERROR,
                    correlationId
                );
                return reject(errorResponse);
            }

            logger.info(
                LOG_PREFIX.concat("Retrieved UID from ISDS API: ", uid),
                correlationId
            );

            // Convert UID to ivUser format
            let ivUser = uid;
            if (!ivUser.includes("@ciam")) {
                ivUser = ivUser + "@ciam";
            }

            logger.info(
                LOG_PREFIX.concat("Formatted ivUser: ", ivUser),
                correlationId
            );

            // Get grants for this ivUser
            const grants = await isamService.getUserGrant(
                args,
                ivUser,
                correlationId,
                requestId
            );

            logger.info(
                LOG_PREFIX.concat("Retrieved ", grants.length, " grant(s) for ivUser: ", ivUser),
                correlationId
            );

            // Find matching grant for the clientId
            for (const grant of grants) {
                if (grant.clientId === clientId) {
                    logger.info(
                        LOG_PREFIX.concat("Found matching grant for clientId: ", clientId, ", grantId: ", grant.id),
                        correlationId
                    );
                    return resolve([ivUser, grant.id]);
                }
            }

            logger.error(
                LOG_PREFIX.concat("No matching grant found for clientId: ", clientId),
                correlationId
            );

            const errorResponse = responseMapper.mapErrorResponse(
                ERRORCODES.VENDOR_ERROR.INTERNAL_SERVER_ERROR.code,
                ERRORCODES.VENDOR_ERROR.INTERNAL_SERVER_ERROR,
                correlationId
            );

            return reject(errorResponse);

        } catch (err) {
            logger.error(
                LOG_PREFIX.concat("Error in findIVUserFromISDS: "),
                err,
                correlationId
            );

            const errorResponse = responseMapper.mapErrorResponse(
                ERRORCODES.VENDOR_ERROR.INTERNAL_SERVER_ERROR.code,
                ERRORCODES.VENDOR_ERROR.INTERNAL_SERVER_ERROR,
                correlationId
            );

            return reject(errorResponse);
        }
    });
};

/**
 * Enhanced method that combines both approaches and returns all iv-users with grants
 */
const findAllIVUsersWithGrants = async (args, requestParams, clientId, correlationId, requestId) => {
    return new Promise(async function (resolve, reject) {
        try {
            logger.info(
                LOG_PREFIX.concat("Starting combined search for IV users with clientId: ", clientId),
                correlationId
            );

            const allIVUsersWithGrants = [];

            // Method 1: Get IV users from credential service (original approach)
            try {
                logger.info(
                    LOG_PREFIX.concat("Attempting to find IV users via Credential Service"),
                    correlationId
                );

                const [credentialIVUser, credentialGrantId] = await findIVUser(
                    args, 
                    requestParams, 
                    clientId, 
                    correlationId, 
                    requestId
                );

                allIVUsersWithGrants.push({
                    source: 'CredentialService',
                    ivUser: credentialIVUser,
                    grantId: credentialGrantId
                });

                logger.info(
                    LOG_PREFIX.concat("Found IV user from Credential Service: ", credentialIVUser),
                    correlationId
                );

            } catch (credentialError) {
                logger.warn(
                    LOG_PREFIX.concat("Failed to get IV user from Credential Service: "),
                    credentialError,
                    correlationId
                );
            }

            // Method 2: Get IV users from ISDS API (new approach)
            try {
                logger.info(
                    LOG_PREFIX.concat("Attempting to find IV users via ISDS API"),
                    correlationId
                );

                const [isdsIVUser, isdsGrantId] = await findIVUserFromISDS(
                    args, 
                    requestParams, 
                    clientId, 
                    correlationId, 
                    requestId
                );

                // Check if this is a duplicate
                const isDuplicate = allIVUsersWithGrants.some(item => 
                    item.ivUser === isdsIVUser && item.grantId === isdsGrantId
                );

                if (!isDuplicate) {
                    allIVUsersWithGrants.push({
                        source: 'ISDS',
                        ivUser: isdsIVUser,
                        grantId: isdsGrantId
                    });

                    logger.info(
                        LOG_PREFIX.concat("Found IV user from ISDS: ", isdsIVUser),
                        correlationId
                    );
                } else {
                    logger.info(
                        LOG_PREFIX.concat("ISDS IV user is duplicate, skipping: ", isdsIVUser),
                        correlationId
                    );
                }

            } catch (isdsError) {
                logger.warn(
                    LOG_PREFIX.concat("Failed to get IV user from ISDS: "),
                    isdsError,
                    correlationId
                );
            }

            // Check if we found any IV users
            if (allIVUsersWithGrants.length === 0) {
                logger.error(
                    LOG_PREFIX.concat("No IV users found through any method for clientId: ", clientId),
                    correlationId
                );

                const errorResponse = responseMapper.mapErrorResponse(
                    ERRORCODES.VENDOR_ERROR.INTERNAL_SERVER_ERROR.code,
                    ERRORCODES.VENDOR_ERROR.INTERNAL_SERVER_ERROR,
                    correlationId
                );

                return reject(errorResponse);
            }

            logger.info(
                LOG_PREFIX.concat("Total IV users found: ", allIVUsersWithGrants.length),
                correlationId
            );

            return resolve(allIVUsersWithGrants);

        } catch (err) {
            logger.error(
                LOG_PREFIX.concat("Error in findAllIVUsersWithGrants: "),
                err,
                correlationId
            );

            const errorResponse = responseMapper.mapErrorResponse(
                ERRORCODES.VENDOR_ERROR.INTERNAL_SERVER_ERROR.code,
                ERRORCODES.VENDOR_ERROR.INTERNAL_SERVER_ERROR,
                correlationId
            );

            return reject(errorResponse);
        }
    });
};

module.exports = { 
    findIVUser, 
    findIVUserFromISDS, 
    findAllIVUsersWithGrants 
};
