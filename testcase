import { jest, describe, it, expect, beforeEach } from '@jest/globals';
import { CreditcardUtilityService } from '../../src/services/creditcardUtilityService';
import { CrossAccountAPICache } from '../../../common/cross-account/cached-apiinformation';
import { ServerError } from '../../util/serverError';
import { ErrorCodes } from '../../util/errorCodes';

// Mock lodash
jest.mock('lodash', () => ({
    cloneDeepWith: jest.fn(),
    isObject: jest.fn(),
    toLower: jest.fn(),
    some: jest.fn()
}));

// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn()
}));

// Mock logger
jest.mock('../../../common/utils/logger', () => ({
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn(),
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn()
}));


@Slf4j

// Mock binRangesResponse
jest.mock('../../model/ccu/binRangesResponse', () => ({
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn(),
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn()
}));

// Mock CrossAccountAPICache
jest.mock('../../../common/cross-account/cached-apiinformation', () => ({
    CrossAccountAPICache: jest.fn().mockImplementation(() => ({
        Value: () => Promise.resolve({
            expected: {
                apiKey: 'test-api-key',
                apiGatewayId: 'test-gateway-id'
            }
        })
    }))
}));

describe('CreditcardUtilityService', () => {
    const mockCorrelationId = 'test-correlation-id';

    beforeEach(() => {
        jest.clearAllMocks();
        // Set up environment variables
        process.env.crossRegion = 'test-region';
        process.env.REGION = 'test-region';
        process.env.crossAccountRoleForCCU = 'test-role';
        process.env.ssmParamCcuApiKey = 'test-param-key';
        process.env.ssmParamCcuGatewayId = 'test-param-gateway';
        process.env.getBinRangesUrl = '12345';

        // Mock global fetch
        global.fetch = jest.fn();
    });

    describe('getBinRanges', () => {
        it('should successfully retrieve bin ranges', () => {
            const mockBinRanges = {
                binList: {
                    bin: [{
                        binStart: '400000',
                        binEnd: '499999',
                        identifier: 'TEST-BIN-001'
                    }]
                }
            };

            (global.fetch as jest.Mock).mockImplementation(() => 
                Promise.resolve({
                    status: 200,
                    json: () => Promise.resolve(mockBinRanges)
                })
            );

            // Create a new instance
            const service = new CreditcardUtilityService(mockCorrelationId);

            return service.getBinRanges().then((result: any) => {
                expect(result).toEqual(mockBinRanges.binList.bin);
                expect(global.fetch).toHaveBeenCalledWith(
                    12345,
                    expect.objectContaining({
                        method: 'GET',
                        headers: expect.objectContaining({
                            'x-api-key': 'test-api-key',
                            'x-apigw-api-id': 'test-gateway-id',
                            'x-request-id': mockCorrelationId
                        })
                    })
                );
            });
        });

        it('should throw error for non-200 response', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.resolve({
                    status: 500,
                    statusText: 'Internal Server Error'
                })
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorMessage,
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorCode
                    )
                );
            });
        });

        it('should throw error when API call fails', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.reject(new Error('Network error'))
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorMessage,
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorCode
                    )
                );
            });
        });

        it('should throw error when cache initialization fails', () => {
            (CrossAccountAPICache as jest.Mock).mockImplementationOnce(() => {
                throw new Error('Cache initialization failed');
            });

            expect(() => new CreditcardUtilityService(mockCorrelationId)).toThrow(
                new ServerError(
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorMessage,
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorCode
                )
            );
        });
    });
});



@Configuration
@RequiredArgsConstructor
@Slf4j
public class BatchConfig {

    @Value("${mc.batch.step-chunk-size}")
    private int chunkSize;

    private final MongoTemplate mongoTemplate;

    @StepScope
    @Bean
    public MongoItemReader<MCRawRecord> mcRawRecordReader(
            @Value("#{jobParameters['fileKey']}") String fileKey,
            @Value("#{stepExecution}") StepExecution stepExecution) {
        
        log.info("Initializing MongoDB reader for fileKey: {}", fileKey);
        
        MongoItemReader<MCRawRecord> reader = new MongoItemReader<>() {
            private boolean isFirstRead = true;
            
            @Override
            protected Object doRead() throws Exception {
                Object item = super.doRead();
                
                // If we've read all items, set the stop flag
                if (item == null && isFirstRead) {
                    log.info("No more records to process for fileKey: {}", fileKey);
                    stepExecution.getJobExecution()
                            .getExecutionContext()
                            .put("stopFlag", true);
                }
                isFirstRead = false;
                return item;
            }
        };
        
        try {
            // Create Query object
            Query query = new Query()
                .addCriteria(Criteria.where("fileKey").is(fileKey))
                .addCriteria(Criteria.where("status").is(RawRecordStatus.PENDING));
                
            reader.setTemplate(mongoTemplate);
            reader.setTargetType(MCRawRecord.class);
            reader.setQuery(query);
            reader.setSort(Map.of("_id", Sort.Direction.ASC));
            reader.setPageSize(chunkSize);
            reader.setCollection("mcRawRecord");
            reader.afterPropertiesSet();
            
            log.info("MongoDB reader initialized successfully with chunk size: {}", chunkSize);
            
        } catch (Exception e) {
            log.error("Failed to initialize MongoDB reader: {}", e.getMessage(), e);
            throw new BeanCreationException("Failed to initialize MongoDB reader", e);
        }
        
        return reader;
    }

    @Bean
    public Step processMCStep() {
        return new StepBuilder("processMCStep", jobRepository)
            .<MCRawRecord, MessageCentreClient>chunk(chunkSize, batchTemplateTransactionManager)
            .reader(mcRawRecordReader(null, null)) // Parameters will be injected by Spring
            .processor(mcRawRecordItemProcessor())
            .writer(mcRawRecordItemWriter())
            .faultTolerant()
            .skip(TemplatedBatchException.class)
            .skipLimit(10)
            .listener(new StepExecutionListener() {
                @Override
                public ExitStatus afterStep(StepExecution stepExecution) {
                    Boolean stopFlag = (Boolean) stepExecution.getJobExecution()
                            .getExecutionContext()
                            .get("stopFlag");
                    
                    if (stopFlag != null && stopFlag) {
                        log.info("Processing completed for the job");
                        return ExitStatus.COMPLETED;
                    }
                    return stepExecution.getExitStatus();
                }
            })
            .build();
    }

    @Bean("batchMCJob")
    public Job batchMCJob() {
        return new JobBuilder("batchMCJob", jobRepository)
                .preventRestart() // Prevents the same job from being restarted
                .start(initialMCStep())
                .next(mcJobExecutionDecider).on("CONTINUE").to(processMCStep())
                .from(mcJobExecutionDecider).on("STOPPED").end()
                .end()
                .build();
    }
}
