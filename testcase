You're right about the initial ISDS call lacking error mapping. Let me add this important gap to the analysis:

# Additional Gap in ISDS Migration: Initial ISDS Call Error Mapping

## 11. Initial ISDS GetCredential Call Error Mapping

### Scenario: Initial ISDS Call Exception Handling
**Data Example:**
- Authentication request made with valid credential format
- Initial `getIsdsGetCredentialResponse()` call fails with ISDS-specific error
- No comprehensive error mapping exists for this initial call

**Potential Breakage:**
```java
// Initial ISDS call in the new approach
try {
    // Call ISDS getCredential
    GetCredentialRequest getCredentialRequest = ISDSGetCredentialMapper.createGetCredentialRequest(
        ISDSServiceUtils.toIsamUserAlias(credential),
        originatorApplicationCatalogueId,
        originatorChannel
    );

    isdsGetCredentialResponse = isdsGetCredentialService.getCredential(getCredentialRequest, headers, requestId);
    
    // Basic error checking without detailed mapping
    if (!ISDSServiceUtils.OPERATION_RESULT_CODE_SUCCESS.equals(operationResultCode)) {
        logger.error("ISDS.getCredential returned error code: " + operationResultCode);
        throw new APIException(
            ErrorCodeDTO._501.toString(),  // Generic system error
            MapperUtils.getErrorMessage(errorCodeMappingString, ErrorCodeDTO._501.toString())
        );
    }
} catch (Exception e) {
    // Generic exception handling
    throw new APIException(
        ErrorCodeDTO._501.toString(),
        MapperUtils.getErrorMessage(errorCodeMappingString, ErrorCodeDTO._501.toString())
    );
}
```

**Critical Issue:** The initial ISDS call maps ALL error conditions to a generic system error (501), whereas the database approach had much more granular error codes for different failure scenarios.

### Specific Error Mapping Gaps:

1. **Credential Not Found**:
   - Database: Returns specific error code 601 for card not found
   - ISDS: All credential not found errors map to generic 501 system error

2. **Service Unavailability**:
   - Database: Specific handling for connection issues vs. data issues
   - ISDS: Both service unavailability and data issues map to same error

3. **Invalid Credential Format**:
   - Database: Explicit validation before DB call, with specific error codes
   - ISDS: Validation happens inside ISDS service, any format error returns generic error

### Real-world Impact:

1. **Degraded User Experience**:
   - Users get generic "system error" messages instead of helpful specific errors
   - Support staff has less insight into actual authentication issues

2. **Troubleshooting Challenges**:
   - Less granular error information makes debugging more difficult
   - Harder to identify patterns in authentication failures

3. **Integration Problems**:
   - Systems expecting specific error codes will receive generic errors
   - Automated flows dependent on specific error codes may break

### Example Scenarios Where This Breaks:

1. **Self-Service Recovery**:
   - Old flow: User enters non-existent card, receives "card not found" error, is directed to card lookup
   - New flow: User receives generic system error, doesn't know what went wrong

2. **Security Monitoring**:
   - Old flow: Security systems tracked specific authentication error patterns
   - New flow: All errors look the same, harder to detect attack patterns

3. **User Guidance**:
   - Old flow: User receives "card expired" message for expired card
   - New flow: User receives generic error, calls support unnecessarily

### Recommended Mitigation:

1. **Create Comprehensive Error Mapping**:
   - Map ISDS error codes to existing application error codes
   - Enhance error handling in the ISDS wrapper to detect specific conditions

2. **Add Error Detection Logic**:
   ```java
   // Enhanced error detection for initial ISDS call
   if (isdsGetCredentialResponse == null) {
       throw new APIException(
           ErrorCodeDTO._501.toString(),
           MapperUtils.getErrorMessage(errorCodeMappingString, ErrorCodeDTO._501.toString())
       );
   }
   
   String operationResultCode = Optional.ofNullable(isdsGetCredentialResponse.getResultInfo())
       .map(ResultInfo::getOperationResultCode)
       .orElse("N/A");
       
   // Map ISDS error codes to application error codes
   switch (operationResultCode) {
       case "CREDENTIAL_NOT_FOUND":
           throw new APIException(
               ErrorCodeDTO._601.toString(),
               MapperUtils.getErrorMessage(errorCodeMappingString, ErrorCodeDTO._601.toString())
           );
       case "CREDENTIAL_SUSPENDED":
           throw new APIException(
               ErrorCodeDTO._603.toString(),
               MapperUtils.getErrorMessage(errorCodeMappingString, ErrorCodeDTO._603.toString())
           );
       // Add mappings for all known ISDS error codes
       default:
           if (!ISDSServiceUtils.OPERATION_RESULT_CODE_SUCCESS.equals(operationResultCode)) {
               throw new APIException(
                   ErrorCodeDTO._501.toString(),
                   MapperUtils.getErrorMessage(errorCodeMappingString, ErrorCodeDTO._501.toString())
               );
           }
   }
   ```

3. **Add Pre-validation**:
   - Add explicit credential format validation before ISDS call
   - Return the same specific error codes as the old flow for validation failures

4. **Enhanced Logging**:
   - Log detailed ISDS error information even when returning generic codes
   - Create mapping tables for support staff to correlate generic errors with specific ISDS issues

This initial ISDS call error mapping gap is particularly critical because it's the first step in the authentication flow. If this step fails with generic errors, users and support staff will have a significantly degraded experience compared to the more informative database-based authentication approach.
