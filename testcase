import { jest, describe, it, expect, beforeEach } from '@jest/globals';
import { CreditcardUtilityService } from '../../src/services/creditcardUtilityService';
import { CrossAccountAPICache } from '../../../common/cross-account/cached-apiinformation';
import { ServerError } from '../../util/serverError';
import { ErrorCodes } from '../../util/errorCodes';

// Mock lodash
jest.mock('lodash', () => ({
    cloneDeepWith: jest.fn(),
    isObject: jest.fn(),
    toLower: jest.fn(),
    some: jest.fn()
}));

// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn()
}));

// Mock logger
jest.mock('../../../common/utils/logger', () => ({
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn(),
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn()
}));


@Slf4j

// Mock binRangesResponse
jest.mock('../../model/ccu/binRangesResponse', () => ({
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn(),
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn()
}));

// Mock CrossAccountAPICache
jest.mock('../../../common/cross-account/cached-apiinformation', () => ({
    CrossAccountAPICache: jest.fn().mockImplementation(() => ({
        Value: () => Promise.resolve({
            expected: {
                apiKey: 'test-api-key',
                apiGatewayId: 'test-gateway-id'
            }
        })
    }))
}));

describe('CreditcardUtilityService', () => {
    const mockCorrelationId = 'test-correlation-id';

    beforeEach(() => {
        jest.clearAllMocks();
        // Set up environment variables
        process.env.crossRegion = 'test-region';
        process.env.REGION = 'test-region';
        process.env.crossAccountRoleForCCU = 'test-role';
        process.env.ssmParamCcuApiKey = 'test-param-key';
        process.env.ssmParamCcuGatewayId = 'test-param-gateway';
        process.env.getBinRangesUrl = '12345';

        // Mock global fetch
        global.fetch = jest.fn();
    });

    describe('getBinRanges', () => {
        it('should successfully retrieve bin ranges', () => {
            const mockBinRanges = {
                binList: {
                    bin: [{
                        binStart: '400000',
                        binEnd: '499999',
                        identifier: 'TEST-BIN-001'
                    }]
                }
            };

            (global.fetch as jest.Mock).mockImplementation(() => 
                Promise.resolve({
                    status: 200,
                    json: () => Promise.resolve(mockBinRanges)
                })
            );

            // Create a new instance
            const service = new CreditcardUtilityService(mockCorrelationId);

            return service.getBinRanges().then((result: any) => {
                expect(result).toEqual(mockBinRanges.binList.bin);
                expect(global.fetch).toHaveBeenCalledWith(
                    12345,
                    expect.objectContaining({
                        method: 'GET',
                        headers: expect.objectContaining({
                            'x-api-key': 'test-api-key',
                            'x-apigw-api-id': 'test-gateway-id',
                            'x-request-id': mockCorrelationId
                        })
                    })
                );
            });
        });

        it('should throw error for non-200 response', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.resolve({
                    status: 500,
                    statusText: 'Internal Server Error'
                })
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorMessage,
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorCode
                    )
                );
            });
        });

        it('should throw error when API call fails', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.reject(new Error('Network error'))
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorMessage,
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorCode
                    )
                );
            });
        });

        it('should throw error when cache initialization fails', () => {
            (CrossAccountAPICache as jest.Mock).mockImplementationOnce(() => {
                throw new Error('Cache initialization failed');
            });

            expect(() => new CreditcardUtilityService(mockCorrelationId)).toThrow(
                new ServerError(
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorMessage,
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorCode
                )
            );
        });
    });
});

package com.ymca.prs0.tbp.config;

import com.hierynomus.smbj.SMBClient;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;
import software.amazon.awssdk.services.s3.S3Client;

import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
class AppConfigTest {

    @InjectMocks
    private AppConfig appConfig;

    private static final String TEST_ACCESS_KEY = "testAccessKey";
    private static final String TEST_SECRET_KEY = "testSecretKey";
    private static final String TEST_ENDPOINT = "http://localhost:4566";

    @BeforeEach
    void setUp() {
        ReflectionTestUtils.setField(appConfig, "accessKey", TEST_ACCESS_KEY);
        ReflectionTestUtils.setField(appConfig, "secretKey", TEST_SECRET_KEY);
        ReflectionTestUtils.setField(appConfig, "s3EndPoint", TEST_ENDPOINT);
    }

    @Test
    void s3Client_ShouldCreateValidClient() {
        // Act
        S3Client s3Client = appConfig.s3Client();

        // Assert
        assertNotNull(s3Client, "S3Client should not be null");
    }

    @Test
    void smbClient_ShouldCreateValidClient() {
        // Act
        SMBClient smbClient = appConfig.smbClient();

        // Assert
        assertNotNull(smbClient, "SMBClient should not be null");
        assertTrue(smbClient.getConfig().isEncryptData(), "SMB encryption should be enabled");
    }

    @Test
    void s3Client_WithInvalidCredentials_ShouldThrowException() {
        // Arrange
        ReflectionTestUtils.setField(appConfig, "accessKey", "");
        ReflectionTestUtils.setField(appConfig, "secretKey", "");

        // Act & Assert
        assertThrows(IllegalArgumentException.class, () -> appConfig.s3Client(),
            "Should throw exception for invalid credentials");
    }

    @Test
    void s3Client_WithInvalidEndpoint_ShouldThrowException() {
        // Arrange
        ReflectionTestUtils.setField(appConfig, "s3EndPoint", "invalid-endpoint");

        // Act & Assert
        assertThrows(IllegalArgumentException.class, () -> appConfig.s3Client(),
            "Should throw exception for invalid endpoint");
    }

    @Test
    void smbClient_ShouldHaveDefaultConfiguration() {
        // Act
        SMBClient smbClient = appConfig.smbClient();

        // Assert
        assertNotNull(smbClient.getConfig(), "SMB config should not be null");
        assertTrue(smbClient.getConfig().isSigningRequired(), "SMB signing should be required");
        assertNotNull(smbClient.getConfig().getDialects(), "SMB dialects should be configured");
    }
}



package com.ymca.prs0.tbp.config;

import com.ymca.prs0.tbp.model.document.MessageTemplateNotification;
import com.ymca.prs0.tbp.repository.MessageTemplateNotificationRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.mongodb.MongoDatabaseFactory;
import org.springframework.data.mongodb.MongoTransactionManager;

import java.util.Arrays;
import java.util.Collections;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class DBConfigTest {

    @Mock
    private MessageTemplateNotificationRepository messageTemplateNotificationRepository;

    @Mock
    private MongoDatabaseFactory mongoDatabaseFactory;

    @InjectMocks
    private DBConfig dbConfig;

    private MessageTemplateNotification template1;
    private MessageTemplateNotification template2;

    @BeforeEach
    void setUp() {
        // Initialize test data
        template1 = new MessageTemplateNotification();
        template1.setNotificationId("notification1");
        template1.setTemplateId("template1");

        template2 = new MessageTemplateNotification();
        template2.setNotificationId("notification2");
        template2.setTemplateId("template2");

        // Clear static map before each test
        DBConfig.getMessageTemplateNotificationMap().clear();
    }

    @Test
    void transactionManager_ShouldCreateValidManager() {
        // Act
        MongoTransactionManager transactionManager = dbConfig.transactionManager(mongoDatabaseFactory);

        // Assert
        assertNotNull(transactionManager, "Transaction manager should not be null");
    }

    @Test
    void loadData_WhenTemplatesExist_ShouldLoadIntoMap() {
        // Arrange
        when(messageTemplateNotificationRepository.findAll())
            .thenReturn(Arrays.asList(template1, template2));

        // Act
        dbConfig.loadData();

        // Assert
        Map<String, MessageTemplateNotification> resultMap = DBConfig.getMessageTemplateNotificationMap();
        assertEquals(2, resultMap.size(), "Map should contain 2 templates");
        assertEquals(template1, resultMap.get("notification1"), "Should contain first template");
        assertEquals(template2, resultMap.get("notification2"), "Should contain second template");
        verify(messageTemplateNotificationRepository).findAll();
    }

    @Test
    void loadData_WhenNoTemplates_ShouldHaveEmptyMap() {
        // Arrange
        when(messageTemplateNotificationRepository.findAll())
            .thenReturn(Collections.emptyList());

        // Act
        dbConfig.loadData();

        // Assert
        Map<String, MessageTemplateNotification> resultMap = DBConfig.getMessageTemplateNotificationMap();
        assertTrue(resultMap.isEmpty(), "Map should be empty");
        verify(messageTemplateNotificationRepository).findAll();
    }

    @Test
    void getMessageTemplateByNotificationId_WhenTemplateExists_ShouldReturnTemplate() {
        // Arrange
        when(messageTemplateNotificationRepository.findAll())
            .thenReturn(Collections.singletonList(template1));
        dbConfig.loadData();

        // Act
        MessageTemplateNotification result = DBConfig.getMessageTemplateByNotificationId("notification1");

        // Assert
        assertNotNull(result, "Should return template for existing notification ID");
        assertEquals(template1, result, "Should return correct template");
    }

    @Test
    void getMessageTemplateByNotificationId_WhenTemplateNotExists_ShouldReturnNull() {
        // Arrange
        when(messageTemplateNotificationRepository.findAll())
            .thenReturn(Collections.emptyList());
        dbConfig.loadData();

        // Act
        MessageTemplateNotification result = DBConfig.getMessageTemplateByNotificationId("nonexistent");

        // Assert
        assertNull(result, "Should return null for non-existent notification ID");
    }

    @Test
    void loadData_WhenRepositoryThrowsException_ShouldHandleGracefully() {
        // Arrange
        when(messageTemplateNotificationRepository.findAll())
            .thenThrow(new RuntimeException("Database error"));

        // Act & Assert
        assertThrows(RuntimeException.class, () -> dbConfig.loadData());
        assertTrue(DBConfig.getMessageTemplateNotificationMap().isEmpty(), 
            "Map should remain empty when loading fails");
    }

    @Test
    void loadData_ShouldUpdateExistingTemplates() {
        // Arrange
        MessageTemplateNotification updatedTemplate = new MessageTemplateNotification();
        updatedTemplate.setNotificationId("notification1");
        updatedTemplate.setTemplateId("updatedTemplate1");

        // First load
        when(messageTemplateNotificationRepository.findAll())
            .thenReturn(Collections.singletonList(template1));
        dbConfig.loadData();

        // Second load with updated template
        when(messageTemplateNotificationRepository.findAll())
            .thenReturn(Collections.singletonList(updatedTemplate));
        dbConfig.loadData();

        // Assert
        Map<String, MessageTemplateNotification> resultMap = DBConfig.getMessageTemplateNotificationMap();
        assertEquals(1, resultMap.size(), "Map should contain 1 template");
        assertEquals(updatedTemplate, resultMap.get("notification1"), 
            "Should contain updated template");
        assertEquals("updatedTemplate1", resultMap.get("notification1").getTemplateId(), 
            "Template should be updated");
    }

    @Test
    void getMessageTemplateNotificationMap_ShouldReturnUnmodifiableMap() {
        // Arrange
        when(messageTemplateNotificationRepository.findAll())
            .thenReturn(Collections.singletonList(template1));
        dbConfig.loadData();

        // Act
        Map<String, MessageTemplateNotification> resultMap = DBConfig.getMessageTemplateNotificationMap();

        // Assert
        assertThrows(UnsupportedOperationException.class, () -> 
            resultMap.put("newKey", template2),
            "Map should not allow direct modifications");
    }
}
