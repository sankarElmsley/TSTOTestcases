import { jest, describe, it, expect, beforeEach } from '@jest/globals';
import { CreditcardUtilityService } from '../../src/services/creditcardUtilityService';
import { CrossAccountAPICache } from '../../../common/cross-account/cached-apiinformation';
import { ServerError } from '../../util/serverError';
import { ErrorCodes } from '../../util/errorCodes';

// Mock lodash
jest.mock('lodash', () => ({
    cloneDeepWith: jest.fn(),
    isObject: jest.fn(),
    toLower: jest.fn(),
    some: jest.fn()
}));

// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn()
}));

// Mock logger
jest.mock('../../../common/utils/logger', () => ({
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn(),
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn()
}));


@Slf4j

// Mock binRangesResponse
jest.mock('../../model/ccu/binRangesResponse', () => ({
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn(),
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn()
}));

// Mock CrossAccountAPICache
jest.mock('../../../common/cross-account/cached-apiinformation', () => ({
    CrossAccountAPICache: jest.fn().mockImplementation(() => ({
        Value: () => Promise.resolve({
            expected: {
                apiKey: 'test-api-key',
                apiGatewayId: 'test-gateway-id'
            }
        })
    }))
}));

describe('CreditcardUtilityService', () => {
    const mockCorrelationId = 'test-correlation-id';

    beforeEach(() => {
        jest.clearAllMocks();
        // Set up environment variables
        process.env.crossRegion = 'test-region';
        process.env.REGION = 'test-region';
        process.env.crossAccountRoleForCCU = 'test-role';
        process.env.ssmParamCcuApiKey = 'test-param-key';
        process.env.ssmParamCcuGatewayId = 'test-param-gateway';
        process.env.getBinRangesUrl = '12345';

        // Mock global fetch
        global.fetch = jest.fn();
    });

    describe('getBinRanges', () => {
        it('should successfully retrieve bin ranges', () => {
            const mockBinRanges = {
                binList: {
                    bin: [{
                        binStart: '400000',
                        binEnd: '499999',
                        identifier: 'TEST-BIN-001'
                    }]
                }
            };

            (global.fetch as jest.Mock).mockImplementation(() => 
                Promise.resolve({
                    status: 200,
                    json: () => Promise.resolve(mockBinRanges)
                })
            );

            // Create a new instance
            const service = new CreditcardUtilityService(mockCorrelationId);

            return service.getBinRanges().then((result: any) => {
                expect(result).toEqual(mockBinRanges.binList.bin);
                expect(global.fetch).toHaveBeenCalledWith(
                    12345,
                    expect.objectContaining({
                        method: 'GET',
                        headers: expect.objectContaining({
                            'x-api-key': 'test-api-key',
                            'x-apigw-api-id': 'test-gateway-id',
                            'x-request-id': mockCorrelationId
                        })
                    })
                );
            });
        });

        it('should throw error for non-200 response', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.resolve({
                    status: 500,
                    statusText: 'Internal Server Error'
                })
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorMessage,
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorCode
                    )
                );
            });
        });

        it('should throw error when API call fails', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.reject(new Error('Network error'))
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorMessage,
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorCode
                    )
                );
            });
        });

        it('should throw error when cache initialization fails', () => {
            (CrossAccountAPICache as jest.Mock).mockImplementationOnce(() => {
                throw new Error('Cache initialization failed');
            });

            expect(() => new CreditcardUtilityService(mockCorrelationId)).toThrow(
                new ServerError(
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorMessage,
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorCode
                )
            );
        });
    });
});




@ExtendWith(MockitoExtension.class)
class MCRawRecordCustomRepositoryImplTest {

    @Mock
    private MongoTemplate mongoTemplate;

    @Mock
    private BulkOperations bulkOperations;

    @Mock
    private IndexOperations indexOperations;

    @InjectMocks
    private MCRawRecordCustomRepositoryImpl repository;

    @BeforeEach
    void setUp() {
        // Set the delete batch size
        ReflectionTestUtils.setField(repository, "deleteBatchSize", 100);

        // Setup index operations mock
        when(mongoTemplate.indexOps(MCRawRecord.class)).thenReturn(indexOperations);
        when(indexOperations.ensureIndex(any(Index.class))).thenReturn("fileKey_index");
        
        // Setup bulk operations mock
        when(mongoTemplate.bulkOps(BulkOperations.BulkMode.UNORDERED, MCRawRecord.class))
            .thenReturn(bulkOperations);
    }

    @Test
    void deleteInBatches_WhenRecordsExist_ShouldDeleteAllBatches() {
        // Given
        String fileKey = "testFile";
        
        // Create test records for first batch
        List<MCRawRecord> firstBatch = createTestBatch(3);
        List<MCRawRecord> emptyBatch = Collections.emptyList();

        // Mock query results for multiple batches
        when(mongoTemplate.find(any(Query.class), eq(MCRawRecord.class)))
            .thenReturn(firstBatch)
            .thenReturn(emptyBatch);

        // Mock bulk operation execution results
        BulkWriteResult firstResult = mock(BulkWriteResult.class);
        when(firstResult.getDeletedCount()).thenReturn(3L);
        
        BulkWriteResult finalResult = mock(BulkWriteResult.class);
        when(finalResult.getDeletedCount()).thenReturn(0L);

        when(bulkOperations.execute())
            .thenReturn(firstResult)
            .thenReturn(finalResult);

        // When
        repository.deleteInBatches(fileKey, 100);

        // Then
        verify(mongoTemplate).indexOps(MCRawRecord.class);
        verify(indexOperations).ensureIndex(argThat(index -> 
            index.getIndexKeys().containsKey("fileKey")));
        
        verify(mongoTemplate, times(2)).find(any(Query.class), eq(MCRawRecord.class));
        verify(bulkOperations, times(2)).execute();
        
        // Verify query contains correct fileKey
        verify(mongoTemplate, times(2)).find(argThat(query -> 
            query.getQueryObject().get("fileKey").toString().equals(fileKey)), 
            eq(MCRawRecord.class));
    }

    @Test
    void deleteInBatches_WhenNoRecordsExist_ShouldHandleEmptyResult() {
        // Given
        String fileKey = "nonExistentFile";
        
        when(mongoTemplate.find(any(Query.class), eq(MCRawRecord.class)))
            .thenReturn(Collections.emptyList());

        BulkWriteResult result = mock(BulkWriteResult.class);
        when(result.getDeletedCount()).thenReturn(0L);
        when(bulkOperations.execute()).thenReturn(result);

        // When
        repository.deleteInBatches(fileKey, 100);

        // Then
        verify(mongoTemplate, times(1)).find(any(Query.class), eq(MCRawRecord.class));
        verify(bulkOperations, times(1)).execute();
    }

    @Test
    void deleteInBatches_WhenIndexCreationFails_ShouldContinueWithDeletion() {
        // Given
        String fileKey = "testFile";
        when(indexOperations.ensureIndex(any(Index.class)))
            .thenThrow(new MongoException("Failed to create index"));

        List<MCRawRecord> batch = createTestBatch(2);
        when(mongoTemplate.find(any(Query.class), eq(MCRawRecord.class)))
            .thenReturn(batch)
            .thenReturn(Collections.emptyList());

        BulkWriteResult result = mock(BulkWriteResult.class);
        when(result.getDeletedCount()).thenReturn(2L, 0L);
        when(bulkOperations.execute()).thenReturn(result);

        // When
        repository.deleteInBatches(fileKey, 100);

        // Then
        verify(mongoTemplate).indexOps(MCRawRecord.class);
        verify(mongoTemplate, times(2)).find(any(Query.class), eq(MCRawRecord.class));
        verify(bulkOperations, times(2)).execute();
    }

    @Test
    void deleteInBatches_WhenBulkOperationFails_ShouldHandleException() {
        // Given
        String fileKey = "testFile";
        List<MCRawRecord> batch = createTestBatch(1);
        
        when(mongoTemplate.find(any(Query.class), eq(MCRawRecord.class)))
            .thenReturn(batch);
        
        when(bulkOperations.execute())
            .thenThrow(new MongoException("Bulk operation failed"));

        // When/Then
        assertThrows(MongoException.class, () -> 
            repository.deleteInBatches(fileKey, 100));
        
        verify(mongoTemplate).find(any(Query.class), eq(MCRawRecord.class));
        verify(bulkOperations).execute();
    }

    private List<MCRawRecord> createTestBatch(int size) {
        return IntStream.range(0, size)
            .mapToObj(i -> {
                MCRawRecord record = new MCRawRecord();
                record.set_id(new ObjectId());
                return record;
            })
            .collect(Collectors.toList());
    }

    // Custom argument matcher for Query objects
    private static class QueryMatcher implements ArgumentMatcher<Query> {
        private final String expectedFileKey;

        public QueryMatcher(String expectedFileKey) {
            this.expectedFileKey = expectedFileKey;
        }

        @Override
        public boolean matches(Query query) {
            return query.getQueryObject().get("fileKey").toString().equals(expectedFileKey);
        }
    }
}
