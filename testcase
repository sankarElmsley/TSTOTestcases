import { jest, describe, it, expect, beforeEach } from '@jest/globals';
import { CreditcardUtilityService } from '../../src/services/creditcardUtilityService';
import { CrossAccountAPICache } from '../../../common/cross-account/cached-apiinformation';
import { ServerError } from '../../util/serverError';
import { ErrorCodes } from '../../util/errorCodes';

// Mock lodash
jest.mock('lodash', () => ({
    cloneDeepWith: jest.fn(),
    isObject: jest.fn(),
    toLower: jest.fn(),
    some: jest.fn()
}));

// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn()
}));

// Mock logger
jest.mock('../../../common/utils/logger', () => ({
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn(),
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn()
}));



/** @type {import('ts-jest').JestConfigWithTsJest} */
export default {
  preset: "ts-jest",
  testEnvironment: "node",
  // Ignore resource files
  testPathIgnorePatterns: [
    "/node_modules/",
    "/test/resources/"
  ],
  // Specify where test files are located
  testMatch: [
    "**/__tests__/**/*.test.ts",
    "**/?(*.)+(spec|test).ts"
  ],
  extensionsToTreatAsEsm: ['.ts'],
  transform: {
    "^.+\\.tsx?$": [
      "ts-jest",
      {
        useESM: true,
        isolatedModules: true,
      },
    ],
  },
};


import { Bin } from "///src/model/ccu/binRangesResponse";
import { CreditcardUtilityService } from "///src/service/ccu/creditcardUtilityService";

import { Bin } from "///src/model/ccu/binRangesResponse";
import { CreditcardUtilityService } from "///src/service/ccu/creditcardUtilityService";
import fetch from 'node-fetch';


// Mock logger
jest.mock("../common/utils/logger", () => ({
  debug: jest.fn(),
  error: jest.fn(),
  info: jest.fn(),
  trace: jest.fn()
}));

import { TransactionMapper } from "./TransactionMapper";
import { Authorization } from "../../model/ccaa/getPendingTransactionsResponse";
import { PostedTransactionsResponse } from "../../model/ccaev/getPostedTransactionsResponse";
import { ApiConstants } from "../../util/constants";

// Define the Transaction type
type Transaction = {
  accountId: string;
  debitCreditMemo: string;
  description?: string;
  transactionId: string;
  transactionDate: string;
  transactionAmount: number;
  transactionCategory: string;
  cardNumberOrig: string;
  eligibleForInstallments?: string;
  merchantCategoryCode?: string;
  merchantName: string;
  postedDate: string;
  transactionCode?: string;
  transRefNum?: string;
};

describe("TransactionMapper Tests", () => {
  const mockCorrelationId = "test-correlation-id";

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("mapRetailPostedTransactions", () => {
    const mockPostedTransactionsResponse: PostedTransactionsResponse = {
      transactionDetail: {
        recordTotal: 2,
        moreRecords: false,
        transactions: [
          {
            accountId: "ACC123",
            debitCreditMemo: "DEBIT",
            description: "Test Transaction 1",
            transactionId: "TXN001",
            transactionDate: "2025-01-01",
            transactionAmount: 100.50,
            transactionCategory: "PURCHASE",
            cardNumberOrig: "1234567890",
            eligibleForInstallments: "Y",
            merchantCategoryCode: "5411",
            merchantName: "Test Merchant 1",
            postedDate: "2025-01-01",
            transactionCode: "123",
            transRefNum: "REF001"
          },
          {
            accountId: "ACC124",
            debitCreditMemo: "CREDIT",
            description: "Test Transaction 2",
            transactionId: "TXN002",
            transactionDate: "2025-01-02",
            transactionAmount: 200.75,
            transactionCategory: "REFUND",
            cardNumberOrig: "0987654321",
            merchantName: "Test Merchant 2",
            postedDate: "2025-01-02",
            transactionCode: "456",
            transRefNum: "REF002"
          }
        ]
      }
    };

    test("should map posted transactions correctly", () => {
      const result = TransactionMapper.mapRetailPostedTransactions(
        mockPostedTransactionsResponse,
        true,
        "1234567890",
        mockCorrelationId
      );

      expect(result.transactions).toHaveLength(2);
      expect(result.availableRecords).toBe(2);
      expect(result.moreRecords).toBe(false);
      expect(result.recordsReturned).toBe(2);
      
      // Verify first transaction mapping
      expect(result.transactions[0]).toEqual(expect.objectContaining({
        amount: 100.50,
        cardNumber: "1234567890",
        descr: "Test Transaction 1",
        eligibleForDispute: true,
        eligibleForInstallments: "Y",
        merchantName: "Test Merchant 1",
        postDate: "2025-01-01",
        promoOfferAvailable: true,
        txnCode: "123",
        txnDate: "2025-01-01"
      }));
    });

    test("should handle empty transactions array", () => {
      const emptyResponse: PostedTransactionsResponse = {
        transactionDetail: {
          recordTotal: 0,
          moreRecords: false,
          transactions: []
        }
      };

      const result = TransactionMapper.mapRetailPostedTransactions(
        emptyResponse,
        true,
        "1234567890",
        mockCorrelationId
      );

      expect(result.transactions).toHaveLength(0);
      expect(result.availableRecords).toBe(0);
      expect(result.recordsReturned).toBe(0);
    });
  });

  describe("mapRetailPendingTransactions", () => {
    const mockPendingTransactions: Authorization[] = [
      {
        authorizationInfo: {
          amount: { value: 150.25 },
          authorizationDate: "2025-01-03",
          type: "PURCHASE",
          transactionReferenceNumber: "REF123",
          authorizationStatus: "APPROVED",
          preAuthorization: "VALID",
          response: "APPROVED"
        },
        authorizationTransactionInfo: {
          originalCardNumber: "1234567890",
          merchantName: "Test Pending Merchant 1"
        }
      }
    ];

    test("should map pending transactions correctly", () => {
      const result = TransactionMapper.mapRetailPendingTransactions(
        mockPendingTransactions,
        mockCorrelationId
      );

      expect(result.transactions).toHaveLength(1);
      expect(result.transactions[0]).toEqual(expect.objectContaining({
        amount: 150.25,
        cardNumber: "1234567890",
        descr: "Test Pending Merchant 1",
        eligibleForDispute: false,
        eligibleForInstallments: "N",
        merchantName: "Test Pending Merchant 1",
        postDate: "",
        txnCode: "",
        txnDate: "2025-01-03",
        txnIndicator: "PURCHASE",
        txnRefNumber: "REF123"
      }));
    });

    test("should handle empty pending transactions array", () => {
      const result = TransactionMapper.mapRetailPendingTransactions(
        [],
        mockCorrelationId
      );

      expect(result.transactions).toHaveLength(0);
    });
  });

  describe("filterEligibleCCPendingTransactions", () => {
    const mockAuthorizationList: Authorization[] = [
      {
        authorizationInfo: {
          authorizationStatus: "APPROVED",
          preAuthorization: "VALID",
          type: "PURCHASE",
          response: "APPROVED",
          amount: { value: 100 },
          authorizationDate: "2025-01-01",
          transactionReferenceNumber: "REF123"
        },
        authorizationTransactionInfo: {
          originalCardNumber: "1234567890",
          merchantName: "Valid Merchant"
        }
      },
      {
        authorizationInfo: {
          authorizationStatus: "DECLINED",
          preAuthorization: "VALID",
          type: "PURCHASE",
          response: "APPROVED",
          amount: { value: 200 },
          authorizationDate: "2025-01-01",
          transactionReferenceNumber: "REF124"
        },
        authorizationTransactionInfo: {
          originalCardNumber: "0987654321",
          merchantName: "Invalid Merchant"
        }
      }
    ];

    test("should filter transactions based on authorization status", () => {
      ApiConstants.PENDING_CC_TXN_AUTH_STATUS_IGNORE = ["DECLINED"];
      ApiConstants.PENDING_CC_TXN_AUTH_TYPES_IGNORE = ["INVALID"];
      ApiConstants.PENDING_CC_TXN_AUTH_RESP_TYPES_IGNORE = ["DECLINED"];

      const result = TransactionMapper.filterEligibleCCPendingTransactions(
        mockAuthorizationList,
        mockCorrelationId
      );

      expect(result).toHaveLength(1);
      expect(result[0].authorizationTransactionInfo.merchantName).toBe("Valid Merchant");
    });
  });

  describe("filterCCPendingTransactionsWithinDateRange", () => {
    const mockTransactions: Authorization[] = [
      {
        authorizationInfo: {
          authorizationStatus: "APPROVED",
          preAuthorization: "VALID",
          type: "PURCHASE",
          response: "APPROVED",
          amount: { value: 100 },
          authorizationDate: "2025-01-15",
          transactionReferenceNumber: "REF125"
        },
        authorizationTransactionInfo: {
          originalCardNumber: "1234567890",
          merchantName: "In Range Merchant"
        }
      },
      {
        authorizationInfo: {
          authorizationStatus: "APPROVED",
          preAuthorization: "VALID",
          type: "PURCHASE",
          response: "APPROVED",
          amount: { value: 200 },
          authorizationDate: "2025-02-15",
          transactionReferenceNumber: "REF126"
        },
        authorizationTransactionInfo: {
          originalCardNumber: "0987654321",
          merchantName: "Out of Range Merchant"
        }
      }
    ];

    test("should filter transactions within date range", () => {
      const result = TransactionMapper.filterCCPendingTransactionsWithinDateRange(
        mockTransactions,
        "2025-01-01",
        "2025-01-31",
        mockCorrelationId
      );

      expect(result).toHaveLength(1);
      expect(result[0].authorizationTransactionInfo.merchantName).toBe("In Range Merchant");
    });

    test("should handle empty transaction list", () => {
      const result = TransactionMapper.filterCCPendingTransactionsWithinDateRange(
        [],
        "2025-01-01",
        "2025-01-31",
        mockCorrelationId
      );

      expect(result).toHaveLength(0);
    });
  });
});
