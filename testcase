import { jest, describe, it, expect, beforeEach } from '@jest/globals';
import { CreditcardUtilityService } from '../../src/services/creditcardUtilityService';
import { CrossAccountAPICache } from '../../../common/cross-account/cached-apiinformation';
import { ServerError } from '../../util/serverError';
import { ErrorCodes } from '../../util/errorCodes';

// Mock lodash
jest.mock('lodash', () => ({
    cloneDeepWith: jest.fn(),
    isObject: jest.fn(),
    toLower: jest.fn(),
    some: jest.fn()
}));

// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn()
}));

// Mock logger
jest.mock('../../../common/utils/logger', () => ({
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn(),
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn()
}));


@Slf4j

// Mock binRangesResponse
jest.mock('../../model/ccu/binRangesResponse', () => ({
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn(),
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn()
}));

// Mock CrossAccountAPICache
jest.mock('../../../common/cross-account/cached-apiinformation', () => ({
    CrossAccountAPICache: jest.fn().mockImplementation(() => ({
        Value: () => Promise.resolve({
            expected: {
                apiKey: 'test-api-key',
                apiGatewayId: 'test-gateway-id'
            }
        })
    }))
}));

describe('CreditcardUtilityService', () => {
    const mockCorrelationId = 'test-correlation-id';

    beforeEach(() => {
        jest.clearAllMocks();
        // Set up environment variables
        process.env.crossRegion = 'test-region';
        process.env.REGION = 'test-region';
        process.env.crossAccountRoleForCCU = 'test-role';
        process.env.ssmParamCcuApiKey = 'test-param-key';
        process.env.ssmParamCcuGatewayId = 'test-param-gateway';
        process.env.getBinRangesUrl = '12345';

        // Mock global fetch
        global.fetch = jest.fn();
    });

    describe('getBinRanges', () => {
        it('should successfully retrieve bin ranges', () => {
            const mockBinRanges = {
                binList: {
                    bin: [{
                        binStart: '400000',
                        binEnd: '499999',
                        identifier: 'TEST-BIN-001'
                    }]
                }
            };

            (global.fetch as jest.Mock).mockImplementation(() => 
                Promise.resolve({
                    status: 200,
                    json: () => Promise.resolve(mockBinRanges)
                })
            );

            // Create a new instance
            const service = new CreditcardUtilityService(mockCorrelationId);

            return service.getBinRanges().then((result: any) => {
                expect(result).toEqual(mockBinRanges.binList.bin);
                expect(global.fetch).toHaveBeenCalledWith(
                    12345,
                    expect.objectContaining({
                        method: 'GET',
                        headers: expect.objectContaining({
                            'x-api-key': 'test-api-key',
                            'x-apigw-api-id': 'test-gateway-id',
                            'x-request-id': mockCorrelationId
                        })
                    })
                );
            });
        });

        it('should throw error for non-200 response', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.resolve({
                    status: 500,
                    statusText: 'Internal Server Error'
                })
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorMessage,
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorCode
                    )
                );
            });
        });

        it('should throw error when API call fails', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.reject(new Error('Network error'))
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorMessage,
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorCode
                    )
                );
            });
        });

        it('should throw error when cache initialization fails', () => {
            (CrossAccountAPICache as jest.Mock).mockImplementationOnce(() => {
                throw new Error('Cache initialization failed');
            });

            expect(() => new CreditcardUtilityService(mockCorrelationId)).toThrow(
                new ServerError(
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorMessage,
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorCode
                )
            );
        });
    });
});

@Test
void processTemplatedBatch_WhenFailedChunksExist_ShouldProcessFailedChunks() {
    // Arrange
    TemplatedBatchDTO dto = new TemplatedBatchDTO();
    dto.setFileKey(FILE_KEY);
    
    RequestInfo requestInfo = RequestInfo.builder()
        .requestId(REQUEST_ID)
        .build();

    // Set up tracker
    Tracker tracker = new Tracker();
    tracker.setFileKey(FILE_KEY);
    tracker.setStatus(S3ObjectStatus.INPROGRESS);
    tracker.setLockStatus(S3LockStatus.N);

    try (MockedStatic<RequestInfoHolder> requestInfoHolder = mockStatic(RequestInfoHolder.class)) {
        requestInfoHolder.when(RequestInfoHolder::getRequestInfo).thenReturn(requestInfo);
        
        // Mock S3Service
        when(s3Service.pollFiles()).thenReturn(Collections.singletonList(FILE_KEY));
        
        // Mock TrackerService conditions
        when(trackerService.isNewFile(FILE_KEY)).thenReturn(false);
        when(trackerService.isFileInProgressOrProcessed(FILE_KEY)).thenReturn(true);
        when(trackerService.isFileAlreadyFailed(FILE_KEY)).thenReturn(false);
        when(trackerService.isFileInterrupted(FILE_KEY)).thenReturn(false);
        when(trackerService.isFileLocked(FILE_KEY)).thenReturn(false);
        when(trackerService.lockFile(FILE_KEY)).thenReturn(true);
        when(trackerService.getTracker(FILE_KEY)).thenReturn(tracker);
        
        // Mock ProcessingEventService
        when(processingEventService.isFailedChunksExist(FILE_KEY)).thenReturn(true);

        // Mock TaskExecutor
        doAnswer(invocation -> {
            Runnable runnable = invocation.getArgument(0);
            runnable.run();
            return null;
        }).when(processBatchTaskExecutor).execute(any(Runnable.class));

        // Act
        ApiResponse response = templatedBatchService.processTemplatedBatch(dto);

        // Assert
        verify(processBatchTaskExecutor, times(1)).execute(any(Runnable.class));
        verify(trackerService, times(1)).lockFile(FILE_KEY);
        
        assertNotNull(response);
        assertEquals(REQUEST_ID, response.getId());
        assertEquals("Task Submitted", response.getMarTechResponse().get("message"));
        assertEquals("Queued", response.getMarTechResponse().get("status"));

        // Verify method call order
        InOrder inOrder = inOrder(trackerService, processingEventService, processBatchTaskExecutor);
        inOrder.verify(trackerService).isNewFile(FILE_KEY);
        inOrder.verify(trackerService).isFileInProgressOrProcessed(FILE_KEY);
        inOrder.verify(trackerService).isFileAlreadyFailed(FILE_KEY);
        inOrder.verify(trackerService).isFileInterrupted(FILE_KEY);
        inOrder.verify(trackerService).isFileLocked(FILE_KEY);
        inOrder.verify(processingEventService).isFailedChunksExist(FILE_KEY);
        inOrder.verify(trackerService).lockFile(FILE_KEY);
        inOrder.verify(processBatchTaskExecutor).execute(any(Runnable.class));
    }
}

// Add helper test for reprocessing failed chunks
@Test
void processFailedChunks_ShouldExecuteSuccessfully() {
    // Arrange
    when(s3Service.getS3ObjectContentLength(FILE_KEY)).thenReturn(1000L);
    when(trackerService.lockFile(FILE_KEY)).thenReturn(true);
    doAnswer(invocation -> {
        Runnable runnable = invocation.getArgument(0);
        runnable.run();
        return null;
    }).when(processBatchTaskExecutor).execute(any(Runnable.class));

    // Act
    templatedBatchService.processFailedChunks(FILE_KEY);

    // Assert
    verify(processBatchTaskExecutor, times(1)).execute(any(Runnable.class));
}

// Add test for the actual file processing
@Test
void processBatchFile_ShouldProcessSuccessfully() {
    // Arrange
    long contentLength = 1000L;
    when(s3Service.getS3ObjectContentLength(FILE_KEY)).thenReturn(contentLength);
    
    Tracker tracker = new Tracker();
    tracker.setFileKey(FILE_KEY);
    tracker.setTotalContentlength(contentLength);
    tracker.setProcessedContentLength(contentLength);
    
    when(trackerService.getTracker(FILE_KEY)).thenReturn(tracker);
    when(trackerService.createTrackerAndLockFile(any(Tracker.class))).thenReturn(true);
    
    ChunkResponse chunkResponse = ChunkResponse.builder()
        .processContentLength(contentLength)
        .currentLeftover("")
        .s3ChunkFailed(false)
        .recordCount(1L)
        .build();
    
    when(templatedBatchProcessor.processChunk(any(), any(), any()))
        .thenReturn(chunkResponse);

    // Act
    templatedBatchService.processNewFile(FILE_KEY);

    // Assert
    verify(processBatchTaskExecutor, times(1)).execute(any(Runnable.class));
}
