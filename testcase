import { jest, describe, it, expect, beforeEach } from '@jest/globals';
import { CreditcardUtilityService } from '../../src/services/creditcardUtilityService';
import { CrossAccountAPICache } from '../../../common/cross-account/cached-apiinformation';
import { ServerError } from '../../util/serverError';
import { ErrorCodes } from '../../util/errorCodes';

// Mock lodash
jest.mock('lodash', () => ({
    cloneDeepWith: jest.fn(),
    isObject: jest.fn(),
    toLower: jest.fn(),
    some: jest.fn()
}));

// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn()
}));

// Mock logger
jest.mock('../../../common/utils/logger', () => ({
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn(),
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn()
}));



/** @type {import('ts-jest').JestConfigWithTsJest} */
export default {
  preset: "ts-jest",
  testEnvironment: "node",
  // Ignore resource files
  testPathIgnorePatterns: [
    "/node_modules/",
    "/test/resources/"
  ],
  // Specify where test files are located
  testMatch: [
    "**/__tests__/**/*.test.ts",
    "**/?(*.)+(spec|test).ts"
  ],
  extensionsToTreatAsEsm: ['.ts'],
  transform: {
    "^.+\\.tsx?$": [
      "ts-jest",
      {
        useESM: true,
        isolatedModules: true,
      },
    ],
  },
};


import { Bin } from "///src/model/ccu/binRangesResponse";
import { CreditcardUtilityService } from "///src/service/ccu/creditcardUtilityService";

import { Bin } from "///src/model/ccu/binRangesResponse";
import { CreditcardUtilityService } from "///src/service/ccu/creditcardUtilityService";
import fetch from 'node-fetch';


// Mock logger
jest.mock("../common/utils/logger", () => ({
  debug: jest.fn(),
  error: jest.fn(),
  info: jest.fn(),
  trace: jest.fn()
}));

import { TransactionMapper } from "./TransactionMapper";
import { Authorization } from "../../model/ccaa/getPendingTransactionsResponse";
import { PostedTransactionsResponse } from "../../model/ccaev/getPostedTransactionsResponse";
import { ApiConstants } from "../../util/constants";
import { TransientCreditCardDataHelper } from "../util/transientCreditCardDataHelper";

describe("TransactionMapper Tests", () => {
  const mockCorrelationId = "test-correlation-id";

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("mapRetailPostedTransactions", () => {
    const mockPostedTransactionsResponse: PostedTransactionsResponse = {
      transactionDetail: {
        recordTotal: 2,
        moreRecords: false,
        transactions: [
          {
            accountId: "ACC123",
            debitCreditMemo: "DEBIT",
            description: "Test Transaction 1",
            transactionId: "TXN001",
            transactionDate: "2025-01-01",
            transactionAmount: 100.50,
            transactionCategory: "PURCHASE",
            cardNumberOrig: "1234567890",
            eligibleForInstallments: "Y",
            merchantCategoryCode: "5411",
            merchantName: "Test Merchant 1",
            postedDate: "2025-01-01",
            transactionCode: "123",
            transRefNum: "REF001"
          },
          {
            accountId: "ACC124",
            debitCreditMemo: "CREDIT",
            description: "Test Transaction 2",
            transactionId: "TXN002",
            transactionDate: "2025-01-02",
            transactionAmount: 200.75,
            transactionCategory: "REFUND",
            cardNumberOrig: "0987654321",
            merchantName: "Test Merchant 2",
            postedDate: "2025-01-02",
            transactionCode: "456",
            transRefNum: "REF002"
          }
        ]
      }
    };

    test("should map posted transactions correctly", () => {
      // Mock TransientCreditCardDataHelper.formatTxnDate
      jest.spyOn(TransientCreditCardDataHelper, 'formatTxnDate')
          .mockImplementation((date) => date);

      const result = TransactionMapper.mapRetailPostedTransactions(
        mockPostedTransactionsResponse,
        true,
        "1234567890",
        mockCorrelationId
      );

      expect(result.transactions).toHaveLength(2);
      expect(result.availableRecords).toBe(2);
      expect(result.moreRecords).toBe(false);
      expect(result.recordsReturned).toBe(2);
      
      // Verify first transaction mapping
      const firstTransaction = result.transactions[0];
      expect(firstTransaction).toEqual(expect.objectContaining({
        amount: 100.50,
        cardNumber: "1234567890",
        descr: "Test Transaction 1",
        eligibleForDispute: true,
        eligibleForInstallments: "Y",
        merchantName: "Test Merchant 1",
        postDate: "2025-01-01",
        promoOfferAvailable: true,
        txnCode: "123",
        txnDate: "2025-01-01"
      }));
    });

    test("should handle empty transactions array", () => {
      const emptyResponse: PostedTransactionsResponse = {
        transactionDetail: {
          recordTotal: 0,
          moreRecords: false,
          transactions: []
        }
      };

      const result = TransactionMapper.mapRetailPostedTransactions(
        emptyResponse,
        true,
        "1234567890",
        mockCorrelationId
      );

      expect(result.transactions).toHaveLength(0);
      expect(result.availableRecords).toBe(0);
      expect(result.recordsReturned).toBe(0);
    });

    test("should set eligibleForDispute to false for non-primary card transactions", () => {
      const result = TransactionMapper.mapRetailPostedTransactions(
        mockPostedTransactionsResponse,
        false, // non-primary card
        "1234567890",
        mockCorrelationId
      );

      const transaction = result.transactions.find(t => t.cardNumber !== "1234567890");
      expect(transaction?.eligibleForDispute).toBe(false);
    });

    test("should handle undefined eligibleForInstallments", () => {
      const response = {
        transactionDetail: {
          recordTotal: 1,
          moreRecords: false,
          transactions: [{
            ...mockPostedTransactionsResponse.transactionDetail.transactions[0],
            eligibleForInstallments: undefined
          }]
        }
      };

      const result = TransactionMapper.mapRetailPostedTransactions(
        response,
        true,
        "1234567890",
        mockCorrelationId
      );

      expect(result.transactions[0].eligibleForInstallments).toBe("N");
    });
  });

  describe("mapRetailPendingTransactions", () => {
    const mockPendingTransactions: Authorization[] = [
      {
        authorizationInfo: {
          amount: { value: 150.25 },
          authorizationDate: "2025-01-03",
          type: "PURCHASE",
          transactionReferenceNumber: "REF123",
          authorizationStatus: "APPROVED",
          preAuthorization: "VALID",
          response: "APPROVED"
        },
        authorizationTransactionInfo: {
          originalCardNumber: "1234567890",
          merchantName: "Test Pending Merchant 1"
        }
      }
    ];

    test("should map pending transactions correctly", () => {
      const result = TransactionMapper.mapRetailPendingTransactions(
        mockPendingTransactions,
        mockCorrelationId
      );

      expect(result.transactions).toHaveLength(1);
      const mappedTransaction = result.transactions[0];
      
      // Test each field individually for better error reporting
      expect(mappedTransaction.amount).toBe(150.25);
      expect(mappedTransaction.cardNumber).toBe("1234567890");
      expect(mappedTransaction.descr).toBe("Test Pending Merchant 1");
      expect(mappedTransaction.eligibleForDispute).toBe(false);
      expect(mappedTransaction.eligibleForInstallments).toBe("N");
      expect(mappedTransaction.merchantName).toBe("Test Pending Merchant 1");
      expect(mappedTransaction.postDate).toBe("");
      expect(mappedTransaction.txnCode).toBe("");
      expect(mappedTransaction.txnDate).toBe("2025-01-03");
      expect(mappedTransaction.txnIndicator).toBe("PURCHASE");
      
      // Check that txnRefNumber matches the transaction reference number
      expect(mappedTransaction.txnRefNumber).toBe("REF123");
    });

    test("should handle empty pending transactions array", () => {
      const result = TransactionMapper.mapRetailPendingTransactions(
        [],
        mockCorrelationId
      );

      expect(result.transactions).toHaveLength(0);
    });
  });
});
