import { jest, describe, it, expect, beforeEach } from '@jest/globals';
import { CreditcardUtilityService } from '../../src/services/creditcardUtilityService';
import { CrossAccountAPICache } from '../../../common/cross-account/cached-apiinformation';
import { ServerError } from '../../util/serverError';
import { ErrorCodes } from '../../util/errorCodes';

// Mock lodash
jest.mock('lodash', () => ({
    cloneDeepWith: jest.fn(),
    isObject: jest.fn(),
    toLower: jest.fn(),
    some: jest.fn()
}));

// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn()
}));

// Mock logger
jest.mock('../../../common/utils/logger', () => ({
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn(),
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn()
}));



/** @type {import('ts-jest').JestConfigWithTsJest} */
export default {
  preset: "ts-jest",
  testEnvironment: "node",
  // Ignore resource files
  testPathIgnorePatterns: [
    "/node_modules/",
    "/test/resources/"
  ],
  // Specify where test files are located
  testMatch: [
    "**/__tests__/**/*.test.ts",
    "**/?(*.)+(spec|test).ts"
  ],
  extensionsToTreatAsEsm: ['.ts'],
  transform: {
    "^.+\\.tsx?$": [
      "ts-jest",
      {
        useESM: true,
        isolatedModules: true,
      },
    ],
  },
};


-----------------------------------------------------------------

import { PutCommand, QueryCommand } from "@aws-sdk/lib-dynamodb";
import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
import CreditCardDetailSessionDataService from "../src/service/ctccd/creditCardDetailSessionDataService";
import { CardDetailSessionData } from "../src/model/cardDetail/cardDetailSessionData";
import { ErrorCodes } from "../src/util/errorCodes";
import { DynamoDBAPIClient } from "../src/service/util/dynamoDbClient";
import { ServerError } from "../src/util/ServerError";
import { TransientCreditCardDataHelper } from "../src/service/util/transientCreditCardDataHelper";

// Mock error logger function
const mockError = jest.fn();

// Mock logger functions
jest.mock("../common/utils/logger", () => ({
    debug: jest.fn(),
    debugWithSanitize: jest.fn(),
    error: jest.fn().mockImplementation((...args) => mockError(...args)),
    trace: jest.fn(),
    info: jest.fn(),
    warn: jest.fn(),
    logBackendServiceRequest: jest.fn(),
    logBackendServiceError: jest.fn(),
    logBackendServiceResponse: jest.fn()
}));

// Mock console functions since they're used in the implementation
global.console.trace = jest.fn();
global.console.debug = jest.fn();
global.console.error = jest.fn();
global.console.info = jest.fn();
global.console.warn = jest.fn();

// Mock AWS SDK utilities
jest.mock("@aws-sdk/util-dynamodb", () => ({
    marshall: jest.fn().mockImplementation(input => input),
    unmarshall: jest.fn().mockImplementation(input => input)
}));

// Mock AWS DynamoDB commands
jest.mock("@aws-sdk/lib-dynamodb", () => ({
    PutCommand: jest.fn().mockImplementation(params => ({ input: params })),
    QueryCommand: jest.fn().mockImplementation(params => ({ input: params }))
}));

// Mock TransientCreditCardDataHelper
jest.mock("../src/service/util/transientCreditCardDataHelper", () => ({
    TransientCreditCardDataHelper: {
        isDateExpired: jest.fn().mockReturnValue(false)
    }
}));

// Mock DynamoDBAPIClient
const mockSendFunction = jest.fn();
jest.mock("../src/service/util/dynamoDbClient", () => ({
    DynamoDBAPIClient: {
        getInstance: jest.fn().mockImplementation(() => ({
            dbDocumentClient: {
                send: mockSendFunction
            }
        }))
    }
}));

// Mock ErrorCodes
jest.mock("../src/util/errorCodes", () => ({
    ErrorCodes: {
        FETCH_CARD_DTL_TEMP_STORAGE_ERROR: {
            errorMessage: "Error fetching card details from temporary storage",
            errorCode: "TCCD-1032"
        },
        SAVE_CARD_DTL_TEMP_STORAGE_ERROR: {
            errorMessage: "Error saving card details to temporary storage",
            errorCode: "TCCD-1031"
        }
    }
}));

// Mock ServerError
jest.mock("../src/util/ServerError", () => ({
    ServerError: class ServerError extends Error {
        constructor(message, code) {
            super(message);
            this.code = code;
        }
    }
}));

describe("CreditCardDetailSessionDataService", () => {
    let service: CreditCardDetailSessionDataService;
    const mockCorrelationId = "test-correlation-id";
    const mockEcifId = "test-ecif";
    const mockSessionId = "test-session";
    const mockAccountIndex = 1;
    const mockTransientCreditCardId = `${mockSessionId}_${mockAccountIndex}`;
    const mockCardDetails = {
        ecifId: mockEcifId,
        transientCreditCardId: mockTransientCreditCardId,
        accountIndex: mockAccountIndex,
        sessionId: mockSessionId,
        accountDetail: {},
        ccarCustomerDetail: {},
        ccarCardDetail: {}
    };

    beforeEach(() => {
        jest.clearAllMocks();
        process.env.CC_DETAIL_DB_TABLE_NAME = "test-table";
        service = new CreditCardDetailSessionDataService(mockCorrelationId);
    });

    afterEach(() => {
        jest.clearAllMocks();
    });

    describe("fetchCardDetails", () => {
        it("should handle empty response", async () => {
            // Mock returning empty Items array
            mockSendFunction.mockResolvedValueOnce({ Items: [] });
            
            const result = await service.fetchCardDetails(mockEcifId, mockSessionId, mockAccountIndex);
            
            expect(result).toBeUndefined();
            expect(mockError).toHaveBeenCalledWith(
                `CreditCardDetailSessionDataService - No items returned while fetching the credit card detail from temporary storage: ${ErrorCodes.FETCH_CARD_DTL_TEMP_STORAGE_ERROR.errorCode}`,
                undefined,
                mockCorrelationId
            );
        });

        it("should handle DynamoDB error", async () => {
            const dbError = new Error("DynamoDB error");
            mockSendFunction.mockRejectedValueOnce(dbError);
            
            await expect(service.fetchCardDetails(mockEcifId, mockSessionId, mockAccountIndex))
                .rejects.toThrow(ErrorCodes.FETCH_CARD_DTL_TEMP_STORAGE_ERROR.errorMessage);
            
            expect(mockError).toHaveBeenCalledWith(
                "CreditCardDetailSessionDataService - FETCH_CARD_DTL_TEMP_STORAGE_ERROR",
                dbError,
                mockCorrelationId
            );
        });

        it("should handle null response", async () => {
            // Mock returning null
            mockSendFunction.mockResolvedValueOnce(null);
            
            const result = await service.fetchCardDetails(mockEcifId, mockSessionId, mockAccountIndex);
            
            expect(result).toBeUndefined();
            expect(mockError).toHaveBeenCalledWith(
                `CreditCardDetailSessionDataService - No items returned while fetching the credit card detail from temporary storage: ${ErrorCodes.FETCH_CARD_DTL_TEMP_STORAGE_ERROR.errorCode}`,
                undefined,
                mockCorrelationId
            );
        });

        it("should handle unexpected error while fetching credit card details", async () => {
            // Set up a mock that will cause an unexpected error during processing
            mockSendFunction.mockResolvedValueOnce({ 
                Items: [{ 
                    ecifId: mockEcifId,
                    transientCreditCardId: mockTransientCreditCardId,
                    accountIndex: mockAccountIndex,
                    sessionId: mockSessionId,
                    // Invalid JSON to cause parsing error
                    accountDetail: "{invalid-json",
                    ccarCustomerDetail: "{}",
                    ccarCardDetail: "{}" 
                }] 
            });
            
            await expect(service.fetchCardDetails(mockEcifId, mockSessionId, mockAccountIndex))
                .rejects.toThrow(ErrorCodes.FETCH_CARD_DTL_TEMP_STORAGE_ERROR.errorMessage);
            
            expect(mockError).toHaveBeenCalledWith(
                "CreditCardDetailSessionDataService - Unexpected error while fetching the credit card detail from temporary storage",
                expect.any(Error),
                mockCorrelationId
            );
        });

        it("should successfully fetch credit card details", async () => {
            const mockData = {
                ecifId: mockEcifId,
                transientCreditCardId: mockTransientCreditCardId,
                accountIndex: mockAccountIndex,
                sessionId: mockSessionId,
                accountDetail: "{}",
                ccarCustomerDetail: "{}",
                ccarCardDetail: "{}",
                ttl: Math.floor(Date.now() / 1000) + 30 * 60
            };
            
            mockSendFunction.mockResolvedValueOnce({ Items: [mockData] });
            const result = await service.fetchCardDetails(mockEcifId, mockSessionId, mockAccountIndex);
            
            expect(result).toBeDefined();
            expect(result?.ecifId).toBe(mockEcifId);
            expect(result?.transientCreditCardId).toBe(mockTransientCreditCardId);
            expect(result?.accountIndex).toBe(mockAccountIndex);
        });
        
        it("should return undefined if data is expired", async () => {
            const mockData = {
                ecifId: mockEcifId,
                transientCreditCardId: mockTransientCreditCardId,
                accountIndex: mockAccountIndex,
                sessionId: mockSessionId,
                accountDetail: "{}",
                ccarCustomerDetail: "{}",
                ccarCardDetail: "{}",
                ttl: Math.floor(Date.now() / 1000) - 60 // Expired timestamp
            };
            
            mockSendFunction.mockResolvedValueOnce({ Items: [mockData] });
            
            // Mock isDateExpired to return true (meaning it's expired)
            (TransientCreditCardDataHelper.isDateExpired as jest.Mock).mockReturnValueOnce(true);
            
            const result = await service.fetchCardDetails(mockEcifId, mockSessionId, mockAccountIndex);
            expect(result).toBeUndefined();
        });
    });
    
    describe("saveCardDetails", () => {
        it("should successfully save card details", async () => {
            mockSendFunction.mockResolvedValueOnce({});
            await service.saveCardDetails(mockCardDetails);
            expect(mockSendFunction).toHaveBeenCalledTimes(1);
        });
        
        it("should handle error when saving card details", async () => {
            const dbError = new Error("DynamoDB error");
            mockSendFunction.mockRejectedValueOnce(dbError);
            
            await expect(service.saveCardDetails(mockCardDetails))
                .rejects.toThrow(ErrorCodes.SAVE_CARD_DTL_TEMP_STORAGE_ERROR.errorMessage);
            
            expect(mockError).toHaveBeenCalledWith(
                "CreditCardDetailSessionDataService - SAVE_CARD_DTL_TEMP_STORAGE_ERROR",
                dbError,
                mockCorrelationId
            );
        });
    });
});
