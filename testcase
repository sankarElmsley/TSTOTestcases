import { jest, describe, it, expect, beforeEach } from '@jest/globals';
import { CreditcardUtilityService } from '../../src/services/creditcardUtilityService';
import { CrossAccountAPICache } from '../../../common/cross-account/cached-apiinformation';
import { ServerError } from '../../util/serverError';
import { ErrorCodes } from '../../util/errorCodes';

// Mock lodash
jest.mock('lodash', () => ({
    cloneDeepWith: jest.fn(),
    isObject: jest.fn(),
    toLower: jest.fn(),
    some: jest.fn()
}));

// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn()
}));

// Mock logger
jest.mock('../../../common/utils/logger', () => ({
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn(),
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn()
}));


@Slf4j

// Mock binRangesResponse
jest.mock('../../model/ccu/binRangesResponse', () => ({
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn(),
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn()
}));

// Mock CrossAccountAPICache
jest.mock('../../../common/cross-account/cached-apiinformation', () => ({
    CrossAccountAPICache: jest.fn().mockImplementation(() => ({
        Value: () => Promise.resolve({
            expected: {
                apiKey: 'test-api-key',
                apiGatewayId: 'test-gateway-id'
            }
        })
    }))
}));

describe('CreditcardUtilityService', () => {
    const mockCorrelationId = 'test-correlation-id';

    beforeEach(() => {
        jest.clearAllMocks();
        // Set up environment variables
        process.env.crossRegion = 'test-region';
        process.env.REGION = 'test-region';
        process.env.crossAccountRoleForCCU = 'test-role';
        process.env.ssmParamCcuApiKey = 'test-param-key';
        process.env.ssmParamCcuGatewayId = 'test-param-gateway';
        process.env.getBinRangesUrl = '12345';

        // Mock global fetch
        global.fetch = jest.fn();
    });

    describe('getBinRanges', () => {
        it('should successfully retrieve bin ranges', () => {
            const mockBinRanges = {
                binList: {
                    bin: [{
                        binStart: '400000',
                        binEnd: '499999',
                        identifier: 'TEST-BIN-001'
                    }]
                }
            };

            (global.fetch as jest.Mock).mockImplementation(() => 
                Promise.resolve({
                    status: 200,
                    json: () => Promise.resolve(mockBinRanges)
                })
            );

            // Create a new instance
            const service = new CreditcardUtilityService(mockCorrelationId);

            return service.getBinRanges().then((result: any) => {
                expect(result).toEqual(mockBinRanges.binList.bin);
                expect(global.fetch).toHaveBeenCalledWith(
                    12345,
                    expect.objectContaining({
                        method: 'GET',
                        headers: expect.objectContaining({
                            'x-api-key': 'test-api-key',
                            'x-apigw-api-id': 'test-gateway-id',
                            'x-request-id': mockCorrelationId
                        })
                    })
                );
            });
        });

        it('should throw error for non-200 response', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.resolve({
                    status: 500,
                    statusText: 'Internal Server Error'
                })
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorMessage,
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorCode
                    )
                );
            });
        });

        it('should throw error when API call fails', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.reject(new Error('Network error'))
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorMessage,
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorCode
                    )
                );
            });
        });

        it('should throw error when cache initialization fails', () => {
            (CrossAccountAPICache as jest.Mock).mockImplementationOnce(() => {
                throw new Error('Cache initialization failed');
            });

            expect(() => new CreditcardUtilityService(mockCorrelationId)).toThrow(
                new ServerError(
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorMessage,
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorCode
                )
            );
        });
    });
});




import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.Date;
import java.util.List;
import java.util.Objects;

/**
 * Service to handle operations related to fetching the last download date of a credit card.
 */
public class LastDownloadDateService {

    private static final Logger logger = LogManager.getLogger(LastDownloadDateService.class);
    private static final String ERROR_CODE_600 = "AD/SE/600";
    private static final String LAST_DOWNLOAD_DATE_ERROR = "LAST DOWNLOAD DATE CARD ERROR";

    /**
     * Retrieves the last download date for a specified credit card account.
     *
     * @param request         The request object containing account index details.
     * @param customerContext The customer context bean containing customer-specific data.
     * @return A response DTO containing the last download date.
     * @throws ServiceErrorException if there is an issue processing the request.
     */
    public LastDownloadDateResponseDTO lastDownloadDate(LastDownloadDateRequestDTO request, CustomerContextBean customerContext) throws ServiceErrorException {
        Objects.requireNonNull(request, "Request cannot be null");
        Objects.requireNonNull(customerContext, "Customer context cannot be null");

        final String methodName = "getLastDownloadDate";
        logger.debug("() >", methodName);

        LastDownloadDateResponseDTO response = new LastDownloadDateResponseDTO();
        CustomerContextModel model = customerContext.getModel();

        try {
            int accountIndex = Integer.parseInt(request.getAccountIndex());
            List<CreditCardAccountBean> creditCardList = model.getAccounts(AccountListSpecifier.CREDIT_CARD_ACCOUNTS_FILTERED_FOR_BOS_SERVICES);

            validateCreditCardList(creditCardList, accountIndex);
            CreditCardAccountBean creditCardBean = creditCardList.get(accountIndex);
            processCreditCard(creditCardBean, response);

        } catch (NumberFormatException e) {
            logger.error("() - Invalid account index format", methodName, e);
            CSUtil.handleError(ERROR_CODE_600);
        } catch (Exception e) {
            logger.error("() - General Exception", methodName, e);
            CSUtil.handleError(LAST_DOWNLOAD_DATE_ERROR);
        }

        logger.debug("() <", methodName);
        return response;
    }

    /**
     * Validates the credit card list and account index.
     *
     * @param creditCardList The list of credit card account beans.
     * @param accountIndex   The index of the account to validate.
     * @throws ServiceErrorException if the credit card list is null or the account index is out of bounds.
     */
    private void validateCreditCardList(List<CreditCardAccountBean> creditCardList, int accountIndex) throws ServiceErrorException {
        if (creditCardList == null || accountIndex >= creditCardList.size()) {
            logger.error("Credit card list is null or account index ({}) is out of bounds", accountIndex);
            CSUtil.handleError(ERROR_CODE_600);
        }
    }

    /**
     * Processes the credit card account to fetch the last download date.
     *
     * @param creditCardBean The credit card account bean.
     * @param response       The response DTO to populate with the last download date.
     * @throws ServiceErrorException if the credit card bean or account is null or if an error occurs while processing.
     */
    private void processCreditCard(CreditCardAccountBean creditCardBean, LastDownloadDateResponseDTO response) throws ServiceErrorException {
        if (creditCardBean == null) {
            logger.error("Credit card bean is null");
            CSUtil.handleError(ERROR_CODE_600);
        }

        CreditCardAccount creditCard = creditCardBean.getCreditCardAccount();
        if (creditCard == null) {
            logger.error("Credit card account is null");
            CSUtil.handleError(ERROR_CODE_600);
        }

        try {
            String accountNumber = sanitizeAccountNumber(creditCard.getAccountNumber());
            Date lastDownloadDate = DadDAO.getLastDownloadDate(accountNumber);
            response.setLastDownloadDate(lastDownloadDate);
        } catch (Exception e) {
            logger.error("Error processing credit card", e);
            CSUtil.handleError(LAST_DOWNLOAD_DATE_ERROR);
        }
    }

    /**
     * Sanitizes the account number by removing spaces and dashes.
     *
     * @param accountNumber The account number to sanitize.
     * @return A sanitized account number with spaces and dashes removed.
     */
    private String sanitizeAccountNumber(String accountNumber) {
        return accountNumber.replaceAll("[\\s-]", "");
    }
}

