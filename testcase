# Potential Breakage Scenarios in ISDS Migration

To better understand where the existing flow might break with the new ISDS-based code, I'll provide specific examples with data scenarios that could cause issues. These examples highlight concrete cases where functionality might break if not properly handled during migration.

## 1. Credential Format Edge Cases

### Scenario: Non-Standard Card Numbers
**Data Example:**
- Customer has card number: "0000123456789101" (starts with zeros but valid format)
- Database approach: Treats as valid card number
- ISDS approach: Might strip leading zeros, causing authentication failure

**Potential Breakage:**
```java
// Database approach processed all 16-digit numbers
if (cardNumber.length() == 16) {
    // Process normally
}

// ISDS might have different normalization
String normalizedCredential = ISDSServiceUtils.toIsamUserAlias(credential);
// If normalizedCredential removes leading zeros, authentication will fail
```

**Real-world impact:** Customers with certain card number formats might suddenly be unable to log in.

## 2. Temporary Password Status Detection

### Scenario: Temporary Password With Special Status
**Data Example:**
- Customer has temporary password status code: "TEMP_SPECIAL" in database
- Old code specifically checked for this status code
- ISDS has a different representation of this status

**Potential Breakage:**
```java
// Database code
if ("TEMP_SPECIAL".equals(tempPasswordInfo.getStatusType())) {
    // Special handling for this case
    return ErrorCodeDTO._606;
} 

// ISDS might not have the same status type or might encode it differently
if (isdsDto.getCredentialStatus() == ISDSServiceUtils.CREDENTIAL_STATUS_TEMPORARY_PASSWORD) {
    // Generic handling without special case
    return ErrorCodeDTO._605; // Different error code!
}
```

**Real-world impact:** Customers might receive incorrect error messages or be allowed to proceed when they shouldn't be.

## 3. Suspension Reason Mapping

### Scenario: Card Suspended Due to Fraud Investigation
**Data Example:**
- Database has suspension reason code: "FRAUD_INVEST" with status flag 1
- Database code returns specific error code 609
- ISDS might have different coding for suspension reasons

**Potential Breakage:**
```java
// Database approach
if (results.getInt("status_flag") == 1) {
    cardSuspensionReason = results.getString("locked_reason");
    if ("FRAUD_INVEST".equalsIgnoreCase(cardSuspensionReason)) {
        result = 2; // Special handling code
        errorCode = "609";
    }
}

// ISDS might not expose the same granular reason codes
if (isdsHelper.isSuspended()) {
    // Generic suspension detection without reason
    errorCode = "603"; // Different error code!
}
```

**Real-world impact:** Fraud cases might not be properly flagged, leading to inconsistent error messages and potential security issues.

## 4. Account Lockout Counting

### Scenario: Failed Authentication Attempts
**Data Example:**
- Customer has 2 failed attempts in database
- Next failed attempt should lock the account
- ISDS might track attempts differently or reset the counter during migration

**Potential Breakage:**
```java
// Database directly updated counter
authenticatorDao.updateBadPasswordCountForDebit(username);
// Counter tracked in database, next failure locks account

// ISDS implementation
// If counter is not synchronized or reset during migration
// Customer might get more than allowed attempts before lockout
```

**Real-world impact:** Security vulnerability where customers get more authentication attempts than they should.

## 5. Card Status Check Differences

### Scenario: Card in "Pre-Activation" Status
**Data Example:**
- Database has card status "P" (pre-activation)
- Custom handling in database code treats this as inactive (status code 4)
- ISDS might use a different status coding system

**Potential Breakage:**
```java
// Database approach with custom mapping
if ("P".equals(cardStatus)) {
    // Treat as status 4 (inactive)
    errorCode = "608";
}

// ISDS might have different status code that doesn't map the same way
if (getCardDetailsRequestHubResponseDTO.getCardStatus().equals("4")) {
    // Only checking for explicit inactive status, missing "P"
    errorCode = "608";
}
```

**Real-world impact:** Cards in certain statuses might be incorrectly allowed or prevented from authenticating.

## 6. Error Code Translation

### Scenario: Database-Specific Error Codes
**Data Example:**
- Database procedure returns error code 8045 (internal procedure code)
- Old code mapped this to application error 704
- ISDS returns different error code for the same condition

**Potential Breakage:**
```java
// Database error handling
catch (SQLException e) {
    if (e.getErrorCode() == 8045) {
        throw new AuthenticationException(
            ErrorCodeDTO._704.toString(),
            MapperUtils.getErrorMessage(errorCodeMappingString, ErrorCodeDTO._704.toString())
        );
    }
}

// ISDS error handling
catch (ChannelsBusinessException e) {
    // Different error code for same condition
    throw new AuthenticationException(
        ErrorCodeDTO._501.toString(), // General system error instead of specific code
        MapperUtils.getErrorMessage(errorCodeMappingString, ErrorCodeDTO._501.toString())
    );
}
```

**Real-world impact:** Systems that depend on specific error codes for business processes might break, and different error messages might confuse users.

## 7. Transaction Timing Issues

### Scenario: Near-Simultaneous Authentication Attempts
**Data Example:**
- Customer attempts login twice within milliseconds
- Database handled this transactionally, recording both attempts
- ISDS API calls might not maintain the same order or atomicity

**Potential Breakage:**
```java
// Database approach (transactional)
// Both operations happen in a single transaction
conn = jdbcTemplateOne.getDataSource().getConnection();
// Check authentication + Update attempt count in one transaction

// ISDS approach (multiple API calls)
AuthenticationResult result = isdsHelper.authenticate(cardNumber, password);
// Separate API call to update attempt count
// If the second call fails, state becomes inconsistent
```

**Real-world impact:** Race conditions could lead to authentication state inconsistencies or security vulnerabilities.

## 8. Timing-Based Validations

### Scenario: Expired Temporary Password
**Data Example:**
- Temporary password expired 1 minute ago
- Database code checked expiry against current database time
- ISDS might use a different time source with slight difference

**Potential Breakage:**
```java
// Database approach
Date todayDate = new Date();
if (tempPasswordInfo.getExpiryDate() != null && todayDate.after(tempPasswordInfo.getExpiryDate())) {
    // Password is expired
    throw new AuthenticationException(EXP_TEMP_PSWD, ...);
}

// ISDS approach
// If ISDS server time and application server time differ slightly
// A password might be considered expired in one system but not the other
```

**Real-world impact:** Customers might be incorrectly allowed to use expired credentials or vice versa.

## 9. Card Replacement Handling

### Scenario: Customer Using Replacement Card
**Data Example:**
- Old card number: "4500123456781234"
- New replacement card: "4500123456785678" 
- Database had specific lookup for replacement card relationship
- ISDS might not maintain the same relationship or require different lookup

**Potential Breakage:**
```java
// Database approach for replacement cards
if (ErrorCodeDTO._601.toString().equalsIgnoreCase(e.getCode())
        && "0000000000000000".equals(dbParam.getPreviousCardNumber())) {
    // Try authentication with previous card
    ar = authenticatorDao.authenticate(dbParam.getPreviousCardNumber(), validateUser.getPassword());
    // Special error code for replacement card scenario
    throw new AuthenticationException(ErrorCodeDTO._604.toString(), ...);
}

// ISDS approach might not have the same detection method
// or might normalize card numbers differently
```

**Real-world impact:** Customers with replacement cards might get generic "invalid credentials" errors instead of helpful guidance.

## 10. Custom Business Rules

### Scenario: Special Card BIN Range Validation
**Data Example:**
- Card BIN range: "450000-455999" has special validation rules
- Database code had custom validation logic for this range
- ISDS might not implement the same special case handling

**Potential Breakage:**
```java
// Database custom validation
if (cardBinDigits >= 450000 && cardBinDigits <= 455999) {
    // Apply special validation rules for premium cards
    boolean validProductCode = customerTypeResolver.validateProductCode(
            customerIdentifier, binHubDTO.getProductCode(), deviceTokenCookie, detailsToLog);
    // Special rules for this BIN range
}

// ISDS might apply generic validation to all BIN ranges
// Missing the special case handling
```

**Real-world impact:** Certain card types might not get their required special handling, leading to incorrect authentication results.

## Recommended Mitigation Strategies

To prevent these specific breakage scenarios:

1. **Comprehensive Data Testing**:
   - Test with a wide variety of real-world data examples
   - Include edge cases like leading zeros, special statuses, etc.

2. **Side-by-Side Validation**:
   - Run both authentication methods in parallel
   - Log discrepancies for analysis before cutting over

3. **Error Code Mapping Layer**:
   - Create a dedicated mapping layer to ensure consistent error codes
   - Match ISDS error responses to existing application error codes

4. **Synchronization Period**:
   - Implement a synchronization period where both systems update account statuses
   - Ensure counters and statuses are synchronized before full migration

5. **Robust Logging**:
   - Add detailed logging around sensitive operations
   - Enable easy comparison between old and new flows during testing

By addressing these specific scenarios and implementing these mitigation strategies, you can significantly reduce the risk of breaking existing functionality during the migration to ISDS-based authentication.
