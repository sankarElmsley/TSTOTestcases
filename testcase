import { jest, describe, it, expect, beforeEach } from '@jest/globals';
import { CreditcardUtilityService } from '../../src/services/creditcardUtilityService';
import { CrossAccountAPICache } from '../../../common/cross-account/cached-apiinformation';
import { ServerError } from '../../util/serverError';
import { ErrorCodes } from '../../util/errorCodes';

// Mock lodash
jest.mock('lodash', () => ({
    cloneDeepWith: jest.fn(),
    isObject: jest.fn(),
    toLower: jest.fn(),
    some: jest.fn()
}));

// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn()
}));

// Mock logger
jest.mock('../../../common/utils/logger', () => ({
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn(),
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn()
}));


@Slf4j

// Mock binRangesResponse
jest.mock('../../model/ccu/binRangesResponse', () => ({
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn(),
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn()
}));

// Mock CrossAccountAPICache
jest.mock('../../../common/cross-account/cached-apiinformation', () => ({
    CrossAccountAPICache: jest.fn().mockImplementation(() => ({
        Value: () => Promise.resolve({
            expected: {
                apiKey: 'test-api-key',
                apiGatewayId: 'test-gateway-id'
            }
        })
    }))
}));

describe('CreditcardUtilityService', () => {
    const mockCorrelationId = 'test-correlation-id';

    beforeEach(() => {
        jest.clearAllMocks();
        // Set up environment variables
        process.env.crossRegion = 'test-region';
        process.env.REGION = 'test-region';
        process.env.crossAccountRoleForCCU = 'test-role';
        process.env.ssmParamCcuApiKey = 'test-param-key';
        process.env.ssmParamCcuGatewayId = 'test-param-gateway';
        process.env.getBinRangesUrl = '12345';

        // Mock global fetch
        global.fetch = jest.fn();
    });

    describe('getBinRanges', () => {
        it('should successfully retrieve bin ranges', () => {
            const mockBinRanges = {
                binList: {
                    bin: [{
                        binStart: '400000',
                        binEnd: '499999',
                        identifier: 'TEST-BIN-001'
                    }]
                }
            };

            (global.fetch as jest.Mock).mockImplementation(() => 
                Promise.resolve({
                    status: 200,
                    json: () => Promise.resolve(mockBinRanges)
                })
            );

            // Create a new instance
            const service = new CreditcardUtilityService(mockCorrelationId);

            return service.getBinRanges().then((result: any) => {
                expect(result).toEqual(mockBinRanges.binList.bin);
                expect(global.fetch).toHaveBeenCalledWith(
                    12345,
                    expect.objectContaining({
                        method: 'GET',
                        headers: expect.objectContaining({
                            'x-api-key': 'test-api-key',
                            'x-apigw-api-id': 'test-gateway-id',
                            'x-request-id': mockCorrelationId
                        })
                    })
                );
            });
        });

        it('should throw error for non-200 response', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.resolve({
                    status: 500,
                    statusText: 'Internal Server Error'
                })
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorMessage,
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorCode
                    )
                );
            });
        });

        it('should throw error when API call fails', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.reject(new Error('Network error'))
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorMessage,
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorCode
                    )
                );
            });
        });

        it('should throw error when cache initialization fails', () => {
            (CrossAccountAPICache as jest.Mock).mockImplementationOnce(() => {
                throw new Error('Cache initialization failed');
            });

            expect(() => new CreditcardUtilityService(mockCorrelationId)).toThrow(
                new ServerError(
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorMessage,
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorCode
                )
            );
        });
    });
});

```java
package com.rbc.prs0.mci.config;

import com.mongodb.ConnectionString;
import com.mongodb.MongoClientSettings;
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import com.rbc.prs0.mci.repository.mongo.MciAuditLogRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.mongodb.MongoDatabaseFactory;
import org.springframework.data.mongodb.MongoTransactionManager;
import org.springframework.data.mongodb.config.EnableMongoAuditing;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.SimpleMongoClientDatabaseFactory;
import org.springframework.data.mongodb.core.mapping.event.AuditingEventListener;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;
import org.springframework.transaction.PlatformTransactionManager;

@Configuration
@EnableMongoRepositories(
        basePackageClasses = MciAuditLogRepository.class,
        mongoTemplateRef = "mcMongoTemplate"
)
@EnableMongoAuditing
@RequiredArgsConstructor
@Slf4j
public class MessageCenterMongoConfig {

    @Value("${spring.data.mongodb.messagecenter.uri}")
    private String mcMongoUri;

    @Value("${spring.data.mongodb.messagecenter.ssl-enabled}")
    private boolean sslEnabled;

    @Value("${spring.data.mongodb.messagecenter.trust-store-location}")
    private String trustStoreLocation;

    @Value("${spring.data.mongodb.messagecenter.trust-store-password}")
    private String trustStorePassword;

    @Bean(name = "mcDatabaseFactory")
    public MongoDatabaseFactory mcDatabaseFactory() {
        return new SimpleMongoClientDatabaseFactory(mcMongoClient(), getMcDatabaseName());
    }

    @Bean(name = "mcMongoTemplate")
    public MongoTemplate mcMongoTemplate() {
        return new MongoTemplate(mcDatabaseFactory());
    }

    @Bean(name = "mcMongoClient")
    public MongoClient mcMongoClient() {
        return MongoClients.create(
                MongoClientSettings.builder()
                        .applyConnectionString(new ConnectionString(mcMongoUri))
                        .build()
        );
    }

    @Bean(name = "mcAuditingHandler")
    public AuditingEventListener mcAuditingEventListener() {
        return new AuditingEventListener(mcIsNewAwareAuditingHandler());
    }

    private IsNewAwareAuditingHandler mcIsNewAwareAuditingHandler() {
        return new IsNewAwareAuditingHandler(getMcMappingContext());
    }

    private MongoMappingContext getMcMappingContext() {
        MongoMappingContext mappingContext = new MongoMappingContext();
        mappingContext.setInitialEntitySet(getInitialEntitySet("com.rbc.prs0.mci.model"));
        return mappingContext;
    }

    private String getMcDatabaseName() {
        return new ConnectionString(mcMongoUri).getDatabase();
    }

    @Bean(name = "mcTransactionManager")
    public PlatformTransactionManager mcMongoTransactionManager(
            @Qualifier("mcDatabaseFactory") MongoDatabaseFactory factory) {
        return new MongoTransactionManager(factory);
    }
}
```

And create a separate config for TBP:


```java
package com.rbc.prs0.tbp.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;
// ... other imports

@Configuration
@EnableMongoRepositories(
    basePackages = "com.rbc.prs0.tbp.repository",
    mongoTemplateRef = "tbpMongoTemplate"
)
public class TbpMongoConfig {

    @Value("${spring.data.mongodb.tbp.uri}")
    private String tbpMongoUri;

    @Bean(name = "tbpDatabaseFactory")
    public MongoDatabaseFactory tbpDatabaseFactory() {
        return new SimpleMongoClientDatabaseFactory(tbpMongoClient(), getTbpDatabaseName());
    }

    @Bean(name = "tbpMongoTemplate")
    public MongoTemplate tbpMongoTemplate() {
        return new MongoTemplate(tbpDatabaseFactory());
    }

    @Bean(name = "tbpMongoClient")
    public MongoClient tbpMongoClient() {
        return MongoClients.create(
                MongoClientSettings.builder()
                        .applyConnectionString(new ConnectionString(tbpMongoUri))
                        .build()
        );
    }

    @Bean(name = "tbpAuditingHandler")
    public AuditingEventListener tbpAuditingEventListener() {
        return new AuditingEventListener(tbpIsNewAwareAuditingHandler());
    }

    private IsNewAwareAuditingHandler tbpIsNewAwareAuditingHandler() {
        return new IsNewAwareAuditingHandler(getTbpMappingContext());
    }

    private MongoMappingContext getTbpMappingContext() {
        MongoMappingContext mappingContext = new MongoMappingContext();
        mappingContext.setInitialEntitySet(getInitialEntitySet("com.rbc.prs0.tbp.model"));
        return mappingContext;
    }

    private String getTbpDatabaseName() {
        return new ConnectionString(tbpMongoUri).getDatabase();
    }

    @Bean(name = "tbpTransactionManager")
    public PlatformTransactionManager tbpMongoTransactionManager(
            @Qualifier("tbpDatabaseFactory") MongoDatabaseFactory factory) {
        return new MongoTransactionManager(factory);
    }
}
```

Key changes:
1. Renamed all beans to have specific prefixes (mc- and tbp-)
2. Added separate auditing handlers for each configuration
3. Created distinct mapping contexts for each MongoDB instance
4. Separated transaction managers
5. Clearly defined repository base packages

Update your application.yml:
```yaml
spring:
  data:
    mongodb:
      messagecenter:
        uri: mongodb://localhost:27017/mc_db
        ssl-enabled: false
        trust-store-location: path/to/truststore
        trust-store-password: password
      tbp:
        uri: mongodb://localhost:27017/tbp_db
```

These changes should resolve the bean naming conflicts. Let me know if you need any clarification!
