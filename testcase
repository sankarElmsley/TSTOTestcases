import { jest, describe, it, expect, beforeEach } from '@jest/globals';
import { CreditcardUtilityService } from '../../src/services/creditcardUtilityService';
import { CrossAccountAPICache } from '../../../common/cross-account/cached-apiinformation';
import { ServerError } from '../../util/serverError';
import { ErrorCodes } from '../../util/errorCodes';

// Mock lodash
jest.mock('lodash', () => ({
    cloneDeepWith: jest.fn(),
    isObject: jest.fn(),
    toLower: jest.fn(),
    some: jest.fn()
}));

// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn()
}));

// Mock logger
jest.mock('../../../common/utils/logger', () => ({
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn(),
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn()
}));


@Slf4j

// Mock binRangesResponse
jest.mock('../../model/ccu/binRangesResponse', () => ({
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn(),
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn()
}));

// Mock CrossAccountAPICache
jest.mock('../../../common/cross-account/cached-apiinformation', () => ({
    CrossAccountAPICache: jest.fn().mockImplementation(() => ({
        Value: () => Promise.resolve({
            expected: {
                apiKey: 'test-api-key',
                apiGatewayId: 'test-gateway-id'
            }
        })
    }))
}));

describe('CreditcardUtilityService', () => {
    const mockCorrelationId = 'test-correlation-id';

    beforeEach(() => {
        jest.clearAllMocks();
        // Set up environment variables
        process.env.crossRegion = 'test-region';
        process.env.REGION = 'test-region';
        process.env.crossAccountRoleForCCU = 'test-role';
        process.env.ssmParamCcuApiKey = 'test-param-key';
        process.env.ssmParamCcuGatewayId = 'test-param-gateway';
        process.env.getBinRangesUrl = '12345';

        // Mock global fetch
        global.fetch = jest.fn();
    });

    describe('getBinRanges', () => {
        it('should successfully retrieve bin ranges', () => {
            const mockBinRanges = {
                binList: {
                    bin: [{
                        binStart: '400000',
                        binEnd: '499999',
                        identifier: 'TEST-BIN-001'
                    }]
                }
            };

            (global.fetch as jest.Mock).mockImplementation(() => 
                Promise.resolve({
                    status: 200,
                    json: () => Promise.resolve(mockBinRanges)
                })
            );

            // Create a new instance
            const service = new CreditcardUtilityService(mockCorrelationId);

            return service.getBinRanges().then((result: any) => {
                expect(result).toEqual(mockBinRanges.binList.bin);
                expect(global.fetch).toHaveBeenCalledWith(
                    12345,
                    expect.objectContaining({
                        method: 'GET',
                        headers: expect.objectContaining({
                            'x-api-key': 'test-api-key',
                            'x-apigw-api-id': 'test-gateway-id',
                            'x-request-id': mockCorrelationId
                        })
                    })
                );
            });
        });

        it('should throw error for non-200 response', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.resolve({
                    status: 500,
                    statusText: 'Internal Server Error'
                })
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorMessage,
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorCode
                    )
                );
            });
        });

        it('should throw error when API call fails', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.reject(new Error('Network error'))
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorMessage,
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorCode
                    )
                );
            });
        });

        it('should throw error when cache initialization fails', () => {
            (CrossAccountAPICache as jest.Mock).mockImplementationOnce(() => {
                throw new Error('Cache initialization failed');
            });

            expect(() => new CreditcardUtilityService(mockCorrelationId)).toThrow(
                new ServerError(
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorMessage,
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorCode
                )
            );
        });
    });
});

package com.ymca.prs0.tbp.config;

import com.hierynomus.mssmb2.SMB2Dialect;
import com.hierynomus.smbj.SMBClient;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.util.ReflectionTestUtils;
import software.amazon.awssdk.auth.credentials.AwsCredentials;
import software.amazon.awssdk.services.s3.S3Client;

import java.lang.reflect.Field;
import java.net.URI;

import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(SpringExtension.class)
@TestPropertySource(properties = {
    "aws.credentials.access-key=testAccessKey",
    "aws.credentials.secret-key=testSecretKey",
    "aws.s3.endpoint=http://localhost:4566"
})
class AppConfigTest {

    @InjectMocks
    private AppConfig appConfig;

    @BeforeEach
    void setUp() {
        ReflectionTestUtils.setField(appConfig, "accessKey", "testAccessKey");
        ReflectionTestUtils.setField(appConfig, "secretKey", "testSecretKey");
        ReflectionTestUtils.setField(appConfig, "s3EndPoint", "http://localhost:4566");
    }

    @Test
    void s3Client_ShouldCreateValidClient() {
        // Act
        S3Client s3Client = appConfig.s3Client();

        // Assert
        assertNotNull(s3Client, "S3Client should not be null");
        
        // Verify endpoint configuration
        Field[] fields = s3Client.getClass().getDeclaredFields();
        boolean hasCorrectEndpoint = false;
        for (Field field : fields) {
            field.setAccessible(true);
            try {
                Object value = field.get(s3Client);
                if (value instanceof URI) {
                    URI uri = (URI) value;
                    assertEquals("http://localhost:4566", uri.toString(), "Endpoint should match configured value");
                    hasCorrectEndpoint = true;
                }
            } catch (IllegalAccessException e) {
                fail("Failed to access field: " + e.getMessage());
            }
            field.setAccessible(false);
        }
        assertTrue(hasCorrectEndpoint, "S3Client should have correct endpoint configured");
    }

    @Test
    void s3Client_ShouldHaveCorrectCredentials() {
        // Act
        S3Client s3Client = appConfig.s3Client();

        // Assert
        assertNotNull(s3Client, "S3Client should not be null");
        
        // Verify credentials
        try {
            Field credentialsProviderField = s3Client.getClass().getDeclaredField("credentialsProvider");
            credentialsProviderField.setAccessible(true);
            Object credentialsProvider = credentialsProviderField.get(s3Client);
            Field credentialsField = credentialsProvider.getClass().getDeclaredField("awsCredentials");
            credentialsField.setAccessible(true);
            AwsCredentials credentials = (AwsCredentials) credentialsField.get(credentialsProvider);
            
            assertEquals("testAccessKey", credentials.accessKeyId(), "Access key should match configured value");
            assertEquals("testSecretKey", credentials.secretAccessKey(), "Secret key should match configured value");
            
        } catch (Exception e) {
            fail("Failed to verify credentials: " + e.getMessage());
        }
    }

    @Test
    void smbClient_ShouldCreateValidClient() {
        // Act
        SMBClient smbClient = appConfig.smbClient();

        // Assert
        assertNotNull(smbClient, "SMBClient should not be null");
        
        // Verify SMB configuration
        try {
            Field configField = smbClient.getClass().getDeclaredField("config");
            configField.setAccessible(true);
            Object config = configField.get(smbClient);
            
            Field dialectsField = config.getClass().getDeclaredField("dialects");
            dialectsField.setAccessible(true);
            Object dialects = dialectsField.get(config);
            
            assertTrue(((Iterable<?>) dialects).iterator().hasNext(), "Dialects should not be empty");
            assertEquals(
                SMB2Dialect.SMB_3_1_1, 
                ((Iterable<?>) dialects).iterator().next(), 
                "Should support SMB 3.1.1 dialect"
            );
            
            Field encryptDataField = config.getClass().getDeclaredField("encryptData");
            encryptDataField.setAccessible(true);
            boolean encryptData = (boolean) encryptDataField.get(config);
            assertTrue(encryptData, "Data encryption should be enabled");
            
        } catch (Exception e) {
            fail("Failed to verify SMB configuration: " + e.getMessage());
        }
    }

    @Test
    void s3Client_ShouldHavePathStyleAccess() {
        // Act
        S3Client s3Client = appConfig.s3Client();

        // Assert
        assertNotNull(s3Client, "S3Client should not be null");
        
        // Verify path style access configuration
        try {
            Field serviceConfigField = s3Client.getClass().getDeclaredField("serviceConfiguration");
            serviceConfigField.setAccessible(true);
            Object serviceConfig = serviceConfigField.get(s3Client);
            
            Field pathStyleField = serviceConfig.getClass().getDeclaredField("pathStyleAccessEnabled");
            pathStyleField.setAccessible(true);
            boolean pathStyleEnabled = (boolean) pathStyleField.get(serviceConfig);
            
            assertTrue(pathStyleEnabled, "Path style access should be enabled");
            
        } catch (Exception e) {
            fail("Failed to verify path style access configuration: " + e.getMessage());
        }
    }

    @Test
    void s3Client_ShouldHaveCorrectTimeoutConfiguration() {
        // Act
        S3Client s3Client = appConfig.s3Client();

        // Assert
        assertNotNull(s3Client, "S3Client should not be null");
        
        try {
            Field httpClientField = s3Client.getClass().getDeclaredField("httpClient");
            httpClientField.setAccessible(true);
            Object httpClient = httpClientField.get(s3Client);
            
            // Verify socket timeout (5 minutes)
            Field socketTimeoutField = httpClient.getClass().getDeclaredField("socketTimeout");
            socketTimeoutField.setAccessible(true);
            Duration socketTimeout = (Duration) socketTimeoutField.get(httpClient);
            assertEquals(Duration.ofMinutes(5), socketTimeout, "Socket timeout should be 5 minutes");
            
            // Verify connection timeout (30 seconds)
            Field connectionTimeoutField = httpClient.getClass().getDeclaredField("connectionTimeout");
            connectionTimeoutField.setAccessible(true);
            Duration connectionTimeout = (Duration) connectionTimeoutField.get(httpClient);
            assertEquals(Duration.ofSeconds(30), connectionTimeout, "Connection timeout should be 30 seconds");
            
        } catch (Exception e) {
            fail("Failed to verify timeout configuration: " + e.getMessage());
        }
    }
}
