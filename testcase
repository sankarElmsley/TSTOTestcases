import { jest, describe, it, expect, beforeEach } from '@jest/globals';
import { CreditcardUtilityService } from '../../src/services/creditcardUtilityService';
import { CrossAccountAPICache } from '../../../common/cross-account/cached-apiinformation';
import { ServerError } from '../../util/serverError';
import { ErrorCodes } from '../../util/errorCodes';

// Mock lodash
jest.mock('lodash', () => ({
    cloneDeepWith: jest.fn(),
    isObject: jest.fn(),
    toLower: jest.fn(),
    some: jest.fn()
}));

// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn()
}));

// Mock logger
jest.mock('../../../common/utils/logger', () => ({
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn(),
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn()
}));


@Slf4j

// Mock binRangesResponse
jest.mock('../../model/ccu/binRangesResponse', () => ({
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn(),
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn()
}));

// Mock CrossAccountAPICache
jest.mock('../../../common/cross-account/cached-apiinformation', () => ({
    CrossAccountAPICache: jest.fn().mockImplementation(() => ({
        Value: () => Promise.resolve({
            expected: {
                apiKey: 'test-api-key',
                apiGatewayId: 'test-gateway-id'
            }
        })
    }))
}));

describe('CreditcardUtilityService', () => {
    const mockCorrelationId = 'test-correlation-id';

    beforeEach(() => {
        jest.clearAllMocks();
        // Set up environment variables
        process.env.crossRegion = 'test-region';
        process.env.REGION = 'test-region';
        process.env.crossAccountRoleForCCU = 'test-role';
        process.env.ssmParamCcuApiKey = 'test-param-key';
        process.env.ssmParamCcuGatewayId = 'test-param-gateway';
        process.env.getBinRangesUrl = '12345';

        // Mock global fetch
        global.fetch = jest.fn();
    });

    describe('getBinRanges', () => {
        it('should successfully retrieve bin ranges', () => {
            const mockBinRanges = {
                binList: {
                    bin: [{
                        binStart: '400000',
                        binEnd: '499999',
                        identifier: 'TEST-BIN-001'
                    }]
                }
            };

            (global.fetch as jest.Mock).mockImplementation(() => 
                Promise.resolve({
                    status: 200,
                    json: () => Promise.resolve(mockBinRanges)
                })
            );

            // Create a new instance
            const service = new CreditcardUtilityService(mockCorrelationId);

            return service.getBinRanges().then((result: any) => {
                expect(result).toEqual(mockBinRanges.binList.bin);
                expect(global.fetch).toHaveBeenCalledWith(
                    12345,
                    expect.objectContaining({
                        method: 'GET',
                        headers: expect.objectContaining({
                            'x-api-key': 'test-api-key',
                            'x-apigw-api-id': 'test-gateway-id',
                            'x-request-id': mockCorrelationId
                        })
                    })
                );
            });
        });

        it('should throw error for non-200 response', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.resolve({
                    status: 500,
                    statusText: 'Internal Server Error'
                })
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorMessage,
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorCode
                    )
                );
            });
        });

        it('should throw error when API call fails', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.reject(new Error('Network error'))
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorMessage,
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorCode
                    )
                );
            });
        });

        it('should throw error when cache initialization fails', () => {
            (CrossAccountAPICache as jest.Mock).mockImplementationOnce(() => {
                throw new Error('Cache initialization failed');
            });

            expect(() => new CreditcardUtilityService(mockCorrelationId)).toThrow(
                new ServerError(
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorMessage,
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorCode
                )
            );
        });
    });
});

```java
    @Test
    void getToken_WhenErrorOccurs_ShouldThrowException() {
        // Arrange
        String tokenUrl = "http://test-token-url";
        AuthCredential authCredential = AuthCredential.builder()
            .clientId("test-client")
            .clientSecret("test-secret")
            .grantType("client_credentials")
            .build();

        RetryStrategy retryStrategy = new RetryStrategy(
            3,                              // maxAttempts
            0.5,                            // jitterFactor
            Duration.ofSeconds(1),          // minInterval
            Duration.ofSeconds(30)          // timeout
        );

        // Setup base configuration
        when(authProperties.getPingFedTokenUrl()).thenReturn(tokenUrl);
        when(authProperties.getAuthCredential(PING_FED_TOKEN_KEY)).thenReturn(authCredential);
        when(authProperties.getRetry()).thenReturn(retryStrategy);

        // Mock WebClient to throw exception immediately
        when(authTokenWebClient.post()).thenThrow(new RuntimeException("API Error"));

        // Act & Assert
        assertThrows(RuntimeException.class, () -> {
            try {
                apiAuthService.getToken(PING_FED_TOKEN_KEY);
            } catch (Exception e) {
                // Verify the error message
                assertEquals("API Error", e.getMessage());
                throw e;
            }
        });

        // Verify interactions
        verify(authProperties).getPingFedTokenUrl();
        verify(authProperties).getAuthCredential(PING_FED_TOKEN_KEY);
        verify(authProperties).getRetry();
        verify(authTokenWebClient).post();
    }
```

Or alternatively, we could try this approach using StepVerifier:

```java
    @Test
    void getToken_WhenErrorOccurs_ShouldThrowException() {
        // Arrange
        String tokenUrl = "http://test-token-url";
        AuthCredential authCredential = AuthCredential.builder()
            .clientId("test-client")
            .clientSecret("test-secret")
            .grantType("client_credentials")
            .build();

        RetryStrategy retryStrategy = new RetryStrategy(
            3,                              // maxAttempts
            0.5,                            // jitterFactor
            Duration.ofSeconds(1),          // minInterval
            Duration.ofSeconds(30)          // timeout
        );

        // Setup mocks
        when(authProperties.getPingFedTokenUrl()).thenReturn(tokenUrl);
        when(authProperties.getAuthCredential(PING_FED_TOKEN_KEY)).thenReturn(authCredential);
        when(authProperties.getRetry()).thenReturn(retryStrategy);
        
        // Setup WebClient chain
        when(authTokenWebClient.mutate()).thenReturn(webClientBuilder);
        when(webClientBuilder.filter(any())).thenReturn(webClientBuilder);
        when(webClientBuilder.build()).thenReturn(authTokenWebClient);
        when(authTokenWebClient.post()).thenReturn(requestBodyUriSpec);
        when(requestBodyUriSpec.uri(any(String.class))).thenReturn(requestBodyUriSpec);
        when(requestBodyUriSpec.contentType(any(MediaType.class))).thenReturn(requestBodyUriSpec);
        when(requestBodyUriSpec.headers(any(Consumer.class))).thenReturn(requestBodyUriSpec);
        when(requestBodyUriSpec.bodyValue(any())).thenReturn(requestHeadersSpec);
        when(requestHeadersSpec.retrieve()).thenReturn(responseSpec);

        // Mock the error response
        RuntimeException apiError = new RuntimeException("API Error");
        when(responseSpec.bodyToMono(AccessTokenInfo.class))
            .thenReturn(Mono.error(apiError));

        // Act & Assert
        StepVerifier.create(Mono.fromCallable(() -> apiAuthService.getToken(PING_FED_TOKEN_KEY)))
            .expectErrorMatches(throwable -> 
                throwable instanceof RuntimeException && 
                throwable.getMessage().contains("API Error"))
            .verify();

        // Verify interactions
        verify(authProperties).getPingFedTokenUrl();
        verify(authProperties).getAuthCredential(PING_FED_TOKEN_KEY);
        verify(authProperties).getRetry();
    }
```

Make sure to add this import for the second approach:
```java
import reactor.test.StepVerifier;
```

Both approaches try to handle the reactive error scenario differently. Try either one and let me know if you still encounter issues. Also, it would be helpful to see the actual implementation of the `getNewToken` method in your `ApiAuthService` to better understand how the error is being handled there.
