// issuedDeviceRequestMapper.js - Request mapper for Issued Device Administration API

const logger = require("../../common/logger/logger.js");
const customerInfoConstants = require("../helper/customerInfoConstants.js");

const APP_CAT_ID = process.env.APP_CAT_ID;
const LOG_PREFIX = "issuedDeviceRequestMapper.js - ";

module.exports = {
    /**
     * Builds the request object for making the call to Issued Device Administration API.
     * @param {string} ecifId
     * @param {string} correlationId
     * @returns {object} request payload
     */
    getIssuedDeviceRequest: (ecifId, correlationId) => {
        logger.trace("In getIssuedDeviceRequest.....", correlationId);

        const requestPayload = {
            ecifID: ecifId,
            expandList: customerInfoConstants.IDA_EXPAND_LIST || "all",
            scope: customerInfoConstants.IDA_SCOPE || "default",
            businessCategory: [
                customerInfoConstants.IDA_BUSINESS_CATEGORY || "WEALTH"
            ],
            originatorData: {
                applicationCatalogueID: customerInfoConstants.APP_CAT_ID,
                country: customerInfoConstants.COUNTRY_CANADA,
                locationID: "192.168.0.0", // Static as per existing pattern
                locationType: "IP",
                channel: "web", 
                employeeUserID: "customerInfoService", // Service identifier
                employeeUserName: "customerInfoService",
                transitNumber: "000" // Default value
            }
        };

        logger.debugWithSanitize(
            requestPayload,
            LOG_PREFIX.concat("getIssuedDeviceRequest.requestPayload"),
            correlationId
        );

        logger.trace("Out getIssuedDeviceRequest.....", correlationId);
        return requestPayload;
    }
};












-----------------------------------------------------------------














// NEW FILE: /ida/issuedDeviceService.js
// Simple service following your existing patterns

const logger = require("../../common/logger/logger.js");
const ciConstants = require("../helper/customerInfoConstants.js");
const customerInfoErrorCodes = require("../helper/customerInfoErrorCodes.js");
const requestMapper = require("./issuedDeviceRequestMapper.js");
const responseMapper = require("../helper/customerInfoResponseMapper.js"); // Reuse existing
const axios = require("axios");
const crossAccountSSMParamHelper = require("../../common/util/aws/crossAccountSSMParamHelper.js");

const LOG_PREFIX = "issuedDeviceService.js - ";
const API_BASE_URL = process.env.ISSUED_DEVICE_ADMINISTRATION_BASE_URI || "https://api2-dev.bmogc.net";
const API_END_POINT = "/api/issued-device-administration/alias/ecif/get";
const APP_CAT_ID = process.env.APP_CAT_ID;
const API_TIMEOUT = process.env.BACKEND_API_TIMEOUT;

const getIssuedDeviceDetails = async (requestParams, correlationId, requestId) => {
    logger.trace(
        LOG_PREFIX.concat("In getIssuedDeviceDetails begins.. with requestId: ", requestId),
        correlationId
    );

    return new Promise(async function (resolve, reject) {
        const startTime = Date.now();
        const apiURL = API_BASE_URL + API_END_POINT;

        // For now, use same SSM pattern as other services - adjust role ARN as needed
        let deviceSSMParams;
        try {
            deviceSSMParams = await crossAccountSSMParamHelper.getCrossAccountSSMParams(
                ciConstants.CROSS_ACCOUNT_ROLE_ARN_CI_DEV2, // Adjust this as needed
                ciConstants.SSM_PARAM.SC_GET_ISSUED_DEVICE_API_KEY,
                ciConstants.SSM_PARAM.SC_GET_ISSUED_DEVICE_AWS_GW_ID,
                correlationId
            );
        } catch (error) {
            logger.error(
                LOG_PREFIX.concat("Error retrieving SSM params for device API"),
                error,
                correlationId
            );
            const errorResponse = responseMapper.mapErrorResponse(
                customerInfoErrorCodes.VENDOR_ERROR.INTERNAL_SERVER_ERROR.statusCode,
                customerInfoErrorCodes.VENDOR_ERROR.INTERNAL_SERVER_ERROR,
                correlationId
            );
            return reject(errorResponse);
        }

        const SC_DEVICE_AWS_KEY = deviceSSMParams[ciConstants.SSM_PARAM.SC_GET_ISSUED_DEVICE_API_KEY];
        const SC_DEVICE_AWS_GW_ID = deviceSSMParams[ciConstants.SSM_PARAM.SC_GET_ISSUED_DEVICE_AWS_GW_ID];

        const payload = requestMapper.getIssuedDeviceRequest(requestParams.ecifId, correlationId);

        logger.logBackendServiceRequest(
            LOG_PREFIX.concat("Device API REST API"),
            payload,
            correlationId
        );

        const headers = {
            "x-api-key": SC_DEVICE_AWS_KEY,
            "x-apigw-api-id": SC_DEVICE_AWS_GW_ID,
            "x-request-id": correlationId,
            "x-fapi-interaction-id": correlationId,
            "x-fapi-financial-id": ciConstants.X_FAPI_FINANCIAL_ID_BMO,
            "x-app-cat-id": APP_CAT_ID,
            "Content-Type": "application/json"
        };

        try {
            const response = await axios.post(apiURL, payload, {
                timeout: API_TIMEOUT,
                headers: headers
            });

            logger.info(
                LOG_PREFIX.concat("response.status: ", response.status),
                correlationId
            );

            logger.logBackendServiceResponse(
                LOG_PREFIX.concat("Device API REST API"),
                startTime,
                response.data,
                correlationId
            );

            if (response.status === 200) {
                return resolve(response.data);
            } else {
                return reject(response.data);
            }

        } catch (error) {
            logger.error(
                LOG_PREFIX.concat("Error calling device API"),
                error,
                correlationId
            );

            const errorResponse = responseMapper.mapErrorResponse(
                customerInfoErrorCodes.VENDOR_ERROR.INTERNAL_SERVER_ERROR.statusCode,
                customerInfoErrorCodes.VENDOR_ERROR.INTERNAL_SERVER_ERROR,
                correlationId
            );
            return reject(errorResponse);
        }
    });
};

--------------------------------------------------------
# Sample Data Flow - Existing Consent Logic

## **Input: JWT Token Sample**

```json
{
  "oid": "12345678901234567890",
  "client_id": "mobile-banking-app-v2",
  "iss": "https://auth.bmo.com",
  "aud": "customer-info-api",
  "exp": 1705123456,
  "iat": 1705119856
}
```

**Extracted Values:**
- `ecifId = "12345678901234567890"`
- `clientId = "mobile-banking-app-v2"`

---

## **STEP 1: Get Retail Consent Details**

### **Request to `retailConsentService.getRetailConsentDetails()`:**
```json
{
  "consentHistoryFilter": "ACTIVE",
  "userId": "12345678901234567890",
  "clientId": "mobile-banking-app-v2"
}
```

### **Response Sample (SUCCESS CASE):**
```json
{
  "permissions": [
    {
      "permissionId": "consent-abc123-def456",
      "permissionLastUpdateDate": "2024-01-15T10:30:00Z",
      "permissionStatus": "ACTIVE",
      "accountList": [
        {
          "accountId": "acc-12345",
          "accountType": "CHECKING",
          "permissions": ["READ", "BALANCE"]
        },
        {
          "accountId": "acc-67890", 
          "accountType": "SAVINGS",
          "permissions": ["READ", "BALANCE", "TRANSACTIONS"]
        }
      ],
      "permissionDefinitions": [
        {
          "permission": "Cust_Contact",
          "description": "Access to customer contact information"
        },
        {
          "permission": "Account_Basic", 
          "description": "Basic account information access"
        }
      ],
      "clientMetaData": {
        "scope": "account_basic customer_contact account_transactions",
        "clientName": "Mobile Banking App",
        "registrationDate": "2024-01-01T00:00:00Z"
      }
    }
  ]
}
```

### **Response Sample (NO PERMISSIONS CASE):**
```json
{
  "permissions": []
}
```

---

## **STEP 2: Check for Permissions**

### **Code Check:**
```javascript
if (!retailConsentResponse.permissions?.[0]) {
    return CUSTOMER_NOT_AUTHORIZED; // FAIL - No permissions exist
}
```

**Success**: `permissions[0]` exists  
**Failure**: Empty `permissions` array → Customer gets `CUSTOMER_NOT_AUTHORIZED`

---

## **STEP 3: `hasActiveConsentAndScopeMatched()` Function**

This function makes **two separate checks**:

### **3.1: `hasActiveConsent(accountList)`**

**Input:** `accountList` from step 1 response
```json
[
  {
    "accountId": "acc-12345",
    "accountType": "CHECKING", 
    "permissions": ["READ", "BALANCE"]
  },
  {
    "accountId": "acc-67890",
    "accountType": "SAVINGS",
    "permissions": ["READ", "BALANCE", "TRANSACTIONS"] 
  }
]
```

**Logic:** `accountList && accountList.length > 0`  
**Result:** `true` (has 2 accounts)

### **3.2: `isScopeMatched(retailConsent)`**

**Input:** Full retail consent from step 1  
**Target Pattern:** `"Cust_Contact"` (from `customerInfoConstants.CUSTOMER_CONSENT_SCOPE`)

**Permission Definitions Check:**
```json
"permissionDefinitions": [
  {
    "permission": "Cust_Contact", ← MATCHES!
    "description": "Access to customer contact information"
  },
  {
    "permission": "Account_Basic",
    "description": "Basic account information access" 
  }
]
```

**Logic:** Loop through `permissionDefinitions`, check if any `permission` matches `"Cust_Contact"`  
**Result:** `true` (found "Cust_Contact" match)

### **Combined Result:**
`hasActiveConsent = true AND isScopeMatched = true` → **PASS**

---

## **STEP 4: DR (Data Recipient) Scope Matching**

### **Function:** `isCustomerConsentedScopesAndDRRegisteredScopesMatched()`

### **Input Data:**
**Customer Consented Scopes** (from `permissionDefinitions`):
```json
[
  {"permission": "Cust_Contact"},
  {"permission": "Account_Basic"}
]
```

**Client Registered Scopes** (from `clientMetaData.scope`):
```json
"scope": "account_basic customer_contact account_transactions"
```
Split into: `["account_basic", "customer_contact", "account_transactions"]`

**FDX to ECIF Mapping** (from SSM):
```json
{
  "fdxToEcif": {
    "account_basic": "Account_Basic",
    "customer_contact": "Cust_Contact", 
    "account_transactions": "Account_Transactions"
  }
}
```

### **Matching Logic:**
```
Customer Scope 1: "Cust_Contact"
  - Check against client scope "account_basic" → fdxToEcif["account_basic"] = "Account_Basic" → NO MATCH
  - Check against client scope "customer_contact" → fdxToEcif["customer_contact"] = "Cust_Contact" → MATCH!
  - Check against client scope "account_transactions" → fdxToEcif["account_transactions"] = "Account_Transactions" → NO MATCH

Customer Scope 2: "Account_Basic"  
  - Check against client scope "account_basic" → fdxToEcif["account_basic"] = "Account_Basic" → MATCH!
  - Check against client scope "customer_contact" → fdxToEcif["customer_contact"] = "Cust_Contact" → NO MATCH
  - Check against client scope "account_transactions" → fdxToEcif["account_transactions"] = "Account_Transactions" → NO MATCH
```

**Results:**
- Customer consented scopes: 2
- Matched scopes: 2  
- **Match!** All customer scopes are covered by client registration

---

## **STEP 5A: SUCCESS CASE - Get Customer Profile**

If all checks pass, call `retrievePartyViewService.getCustomerProfileDetails()`

### **Sample Customer Profile Response:**
```json
{
  "person": {
    "personName": [
      {
        "nameUsageType": "1",
        "givenNameOne": "John",
        "givenNameTwo": "Michael", 
        "lastName": "Smith"
      }
    ],
    "partyAddress": [
      {
        "addressUsageType": "100000",
        "address": {
          "addressLineOne": "123 Main Street",
          "addressLineTwo": "Apt 4B",
          "city": "Toronto",
          "provinceStateTypeValue": "ON",
          "zipPostalCode": "M5V 3A8",
          "countryTypeCode": "CA"
        }
      }
    ],
    "partyContactMethod": [
      {
        "contactMethodUsageType": "100008",
        "contactMethod": {
          "contactMethodType": "2",
          "referenceNumber": "john.smith@email.com"
        }
      },
      {
        "contactMethodUsageType": "100000", 
        "contactMethod": {
          "contactMethodType": "1",
          "phoneNumber": {
            "phoneCountryCode": "1"
          },
          "referenceNumber": "416-555-0123"
        }
      }
    ]
  }
}
```

### **Final Response to Customer:**
```json
{
  "name": {
    "first": "John",
    "middle": "Michael",
    "last": "Smith"
  },
  "addresses": [
    {
      "line1": "123 Main Street",
      "line2": "Apt 4B", 
      "line3": "",
      "city": "Toronto",
      "region": "ON",
      "postalCode": "M5V 3A8",
      "country": "CA",
      "type": "HOME"
    }
  ],
  "email": ["john.smith@email.com"],
  "telephones": [
    {
      "country": "1",
      "number": "+416-555-0123",
      "type": "HOME"
    }
  ]
}
```

---

## **STEP 5B: FAILURE CASE - Scope Mismatch & Delete**

### **Scenario:** Customer has different scopes than client expects

**Customer Consented Scopes:**
```json
[{"permission": "Cust_Contact"}]
```

**Client Registered Scopes:**
```json
"scope": "account_basic account_transactions"
```

**Mapping Result:**
- Customer has: `"Cust_Contact"`
- Client needs: `"Account_Basic"` + `"Account_Transactions"`  
- **Mismatch!** Customer scope doesn't cover what client registered for

### **Delete Process Begins:**

#### **5B.1: Find IV User**

**Call to `retrievePartyIdentification.getCustomerIdentificationDetails()`:**
```json
{
  "originatorData": {
    "applicationCatalogueId": "3384",
    "country": "CAN"
  },
  "outputIdType": "OCIF",
  "identifier": {
    "id": "12345678901234567890",
    "type": "ECIF"
  }
}
```

**Response:**
```json
{
  "identifier": {
    "id": "OCIF98765432109876543210",
    "type": "OCIF"
  }
}
```

#### **5B.2: Get Credential Service Users**

**Call to `credentialService.getCustomerISAMCredentials()`:**
```json
["user123", "user456@ciam", "user789"]
```

#### **5B.3: Get User Grants**

For each IV user, call `isamService.getUserGrant()`:

**Sample Grant Response:**
```json
[
  {
    "id": "grant-xyz789",
    "clientId": "mobile-banking-app-v2",
    "scopes": ["account_basic", "customer_contact"],
    "status": "ACTIVE"
  },
  {
    "id": "grant-abc123", 
    "clientId": "different-client",
    "scopes": ["account_basic"],
    "status": "ACTIVE"
  }
]
```

**Match Found:** `grant-xyz789` matches `clientId = "mobile-banking-app-v2"`  
**Result:** `ivUser = "user456@ciam"`, `grantId = "grant-xyz789"`

#### **5B.4: Delete Consent**

**Delete Request Payload:**
```json
{
  "originatorData": {
    "applicationCatalogueId": "3384",
    "country": "ca"
  },
  "userId": "12345678901234567890",
  "iv-user": "user456@ciam",
  "permissions": [
    {
      "permissionId": "consent-abc123-def456",
      "permissionLastUpdateDate": "2024-01-15T10:30:00Z",
      "clientId": "mobile-banking-app-v2",
      "grantId": "grant-xyz789"
    }
  ]
}
```

**Expected Response:** `HTTP 204 No Content` (successful deletion)

**Final Result:** Customer gets `CUSTOMER_NOT_AUTHORIZED` error

---

## **SQS Event Sample**

### **Success Case:**
```json
{
  "customerId": "12345678901234567890",
  "clientId": "mobile-banking-app-v2", 
  "consentId": "consent-abc123-def456",
  "logRecStatus": "ACTIVE",
  "lastAccessedDate": "20240115",
  "fapiInteractionID": "correlation-id-12345"
}
```

### **With New Device API Fallback:**
```json
{
  "customerId": "12345678901234567890",
  "clientId": "mobile-banking-app-v2",
  "authMethod": "device_credential",
  "deviceUid": "57BD5EEB67D349B1838B2F5419B46446", 
  "fallbackReason": "scope_mismatch_deleted",
  "businessCategory": ["WEALTH-NESBITTBURNS"],
  "logRecStatus": "ACTIVE",
  "lastAccessedDate": "20240115",
  "fapiInteractionID": "correlation-id-12345"
}
```

This shows exactly how your current flow works with real data examples, and where the new device API would fit in as a fallback mechanism.

module.exports = {
    getIssuedDeviceDetails
};

----------------------------------
We're aligned on proceeding with the merge; however, we need clarity on the following questions before moving forward.

To ensure our ask is clearly understood, I had a call with Paritosh to validate the details with his subject matter expertise, and we both arrived at the same conclusion:

Before performing the delete operation, the system requires both the ivUserId and grantId as inputs. Once these are available, the delete action proceeds.

With the new API, we intend to call it using the ecifID. In this context:

Does the uid returned in the new API response represent the same value as the previously used ivUserId?

Does the new API also provide the associated grant information? If so, what is the mapping between the response and the grantId?

In the existing implementation, a separate API is called to retrieve the grant information. We're trying to determine whether that step is still required or if the new API now consolidates both pieces of information.

Let me know if you'd like this adapted into an email format or shortened for a chat message.
