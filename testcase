import { jest, describe, it, expect, beforeEach } from '@jest/globals';
import { CreditcardUtilityService } from '../../src/services/creditcardUtilityService';
import { CrossAccountAPICache } from '../../../common/cross-account/cached-apiinformation';
import { ServerError } from '../../util/serverError';
import { ErrorCodes } from '../../util/errorCodes';

// Mock lodash
jest.mock('lodash', () => ({
    cloneDeepWith: jest.fn(),
    isObject: jest.fn(),
    toLower: jest.fn(),
    some: jest.fn()
}));

// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn()
}));

// Mock logger
jest.mock('../../../common/utils/logger', () => ({
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn(),
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn()
}));


package com.ymca.prs0.tbp.batch;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.ymca.prs0.tbp.exception.TemplatedBatchException;
import com.ymca.prs0.tbp.model.ApiResponse;
import com.ymca.prs0.tbp.model.RawRecordStatus;
import com.ymca.prs0.tbp.model.document.MCRawRecord;
import com.ymca.prs0.tbp.model.domain.mc.MessageCentreBatchRequest;
import com.ymca.prs0.tbp.model.domain.mc.MessageCentreBatchResponse;
import com.ymca.prs0.tbp.model.domain.mc.MessageCentreClient;
import com.ymca.prs0.tbp.model.domain.mc.MessageCentreError;
import com.ymca.prs0.tbp.repository.MCRawRecordRepository;
import com.rbc.prs0.mci.service.MessageCentreBatchService;
import com.rbc.prs0.mci.model.MessageCentreBatchDto;
import com.rbc.prs0.mci.model.MessageCentreClientDto;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.item.Chunk;
import org.springframework.batch.item.ItemWriter;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@RequiredArgsConstructor
public class MCRawRecordItemWriter implements ItemWriter<MessageCentreClient> {

    private final MessageCentreBatchService messageCentreBatchService;
    private final MCRawRecordRepository mcRawRecordRepository;
    private final ObjectMapper mapper;

    @Override
    public void write(Chunk<? extends MessageCentreClient> chunk) throws JsonProcessingException {
        List<MessageCentreClientDto> messageCentreClientDtoList = new ArrayList<>();

        // Convert MessageCentreClient to MessageCentreClientDto
        for (MessageCentreClient messageCentreClient : chunk) {
            MessageCentreClientDto dto = MessageCentreClientDto.builder()
                    .messageTemplateId(messageCentreClient.getMessageTemplateId())
                    .recipientIdentifier(messageCentreClient.getRecipientIdentifier())
                    .language(messageCentreClient.getLanguage())
                    .recipientIdentifierType(messageCentreClient.getRecipientIdentifierType())
                    .messageCentre(messageCentreClient.getMessageCentre())
                    .processingCentre(messageCentreClient.getProcessingCentre())
                    .formId(messageCentreClient.getFormId())
                    .messageSubject(messageCentreClient.getMessageSubject())
                    .messageContent(messageCentreClient.getMessageContent())
                    .dynamicLinks(messageCentreClient.getDynamicLinks())
                    .build();

            messageCentreClientDtoList.add(dto);
        }

        // Create MessageCentreBatchDto
        MessageCentreBatchDto batchDto = MessageCentreBatchDto.builder()
                .clients(messageCentreClientDtoList)
                .build();

        // Direct service call instead of web service
        ApiResponse apiResponse = messageCentreBatchService.send(batchDto);

        try {
            updateRecordStatus(apiResponse, new ArrayList<>(chunk.getItems()));
        } catch (TemplatedBatchException ex) {
            log.error("Exception occurred during updating records MCStatus: ", ex);
        }
    }

    @Transactional
    public void updateRecordStatus(ApiResponse apiResponse, List<MessageCentreClient> messageCentreClientList) {
        if (apiResponse != null && apiResponse.getMarTechResponse() != null) {
            MessageCentreBatchResponse response = mapper.convertValue(apiResponse.getMarTechResponse(), MessageCentreBatchResponse.class);
            List<String> idList = messageCentreClientList.stream()
                    .map(MessageCentreClient::getId)
                    .collect(Collectors.toList());

            if (response.getStatus().equalsIgnoreCase("SUCCESS") && response.getError().isEmpty()) {
                mcRawRecordRepository.updateStatusForIds(idList, RawRecordStatus.PROCESSED);
            } else if (response.getStatus().equalsIgnoreCase("PARTIAL_SUCCESS") && !response.getError().isEmpty()) {
                List<MCRawRecord> mcRawRecordList = mcRawRecordRepository.findAllById(idList);
                Map<String, String> errorIdMsgMap = response.getError().stream()
                        .collect(Collectors.toMap(MessageCentreError::getId, MessageCentreError::getMessage));

                mcRawRecordList.forEach(mcRawRecord -> {
                    if (errorIdMsgMap.containsKey(mcRawRecord.get_id().toString())) {
                        mcRawRecord.setErrorMsg(errorIdMsgMap.get(mcRawRecord.get_id().toString()));
                        mcRawRecord.setStatus(RawRecordStatus.FAILED);
                    } else {
                        mcRawRecord.setStatus(RawRecordStatus.PROCESSED);
                    }
                });

                mcRawRecordRepository.saveAll(mcRawRecordList);
                log.info("Partial success: Failed {} out of {} during MessageCenter processing", response.getError().size(), idList.size());
            } else if (response.getStatus().equalsIgnoreCase("FAILED") && !response.getError().isEmpty() && response.getError().get(0) != null) {
                mcRawRecordRepository.updateStatusAndErrorMsgForIds(idList, RawRecordStatus.FAILED, response.getError().get(0).getMessage());
            }
        }
    }
}

// Mock binRangesResponse
jest.mock('../../model/ccu/binRangesResponse', () => ({
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn(),
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn()
}));

// Mock CrossAccountAPICache
jest.mock('../../../common/cross-account/cached-apiinformation', () => ({
    CrossAccountAPICache: jest.fn().mockImplementation(() => ({
        Value: () => Promise.resolve({
            expected: {
                apiKey: 'test-api-key',
                apiGatewayId: 'test-gateway-id'
            }
        })
    }))
}));

describe('CreditcardUtilityService', () => {
    const mockCorrelationId = 'test-correlation-id';

    beforeEach(() => {
        jest.clearAllMocks();
        // Set up environment variables
        process.env.crossRegion = 'test-region';
        process.env.REGION = 'test-region';
        process.env.crossAccountRoleForCCU = 'test-role';
        process.env.ssmParamCcuApiKey = 'test-param-key';
        process.env.ssmParamCcuGatewayId = 'test-param-gateway';
        process.env.getBinRangesUrl = '12345';

        // Mock global fetch
        global.fetch = jest.fn();
    });

    describe('getBinRanges', () => {
        it('should successfully retrieve bin ranges', () => {
            const mockBinRanges = {
                binList: {
                    bin: [{
                        binStart: '400000',
                        binEnd: '499999',
                        identifier: 'TEST-BIN-001'
                    }]
                }
            };

            (global.fetch as jest.Mock).mockImplementation(() => 
                Promise.resolve({
                    status: 200,
                    json: () => Promise.resolve(mockBinRanges)
                })
            );

            // Create a new instance
            const service = new CreditcardUtilityService(mockCorrelationId);

            return service.getBinRanges().then((result: any) => {
                expect(result).toEqual(mockBinRanges.binList.bin);
                expect(global.fetch).toHaveBeenCalledWith(
                    12345,
                    expect.objectContaining({
                        method: 'GET',
                        headers: expect.objectContaining({
                            'x-api-key': 'test-api-key',
                            'x-apigw-api-id': 'test-gateway-id',
                            'x-request-id': mockCorrelationId
                        })
                    })
                );
            });
        });

        it('should throw error for non-200 response', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.resolve({
                    status: 500,
                    statusText: 'Internal Server Error'
                })
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorMessage,
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorCode
                    )
                );
            });
        });

        it('should throw error when API call fails', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.reject(new Error('Network error'))
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorMessage,
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorCode
                    )
                );
            });
        });

        it('should throw error when cache initialization fails', () => {
            (CrossAccountAPICache as jest.Mock).mockImplementationOnce(() => {
                throw new Error('Cache initialization failed');
            });

            expect(() => new CreditcardUtilityService(mockCorrelationId)).toThrow(
                new ServerError(
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorMessage,
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorCode
                )
            );
        });
    });
});
