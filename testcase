import { jest, describe, it, expect, beforeEach } from '@jest/globals';
import { CreditcardUtilityService } from '../../src/services/creditcardUtilityService';
import { CrossAccountAPICache } from '../../../common/cross-account/cached-apiinformation';
import { ServerError } from '../../util/serverError';
import { ErrorCodes } from '../../util/errorCodes';

// Mock lodash
jest.mock('lodash', () => ({
    cloneDeepWith: jest.fn(),
    isObject: jest.fn(),
    toLower: jest.fn(),
    some: jest.fn()
}));

// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn()
}));

// Mock logger
jest.mock('../../../common/utils/logger', () => ({
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn(),
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn()
}));


@Slf4j

// Mock binRangesResponse
jest.mock('../../model/ccu/binRangesResponse', () => ({
    logBackendServiceRequest: jest.fn(),
    logBackendServiceResponse: jest.fn(),
    logBackendServiceError: jest.fn(),
    error: jest.fn(),
    trace: jest.fn(),
    info: jest.fn()
}));

// Mock CrossAccountAPICache
jest.mock('../../../common/cross-account/cached-apiinformation', () => ({
    CrossAccountAPICache: jest.fn().mockImplementation(() => ({
        Value: () => Promise.resolve({
            expected: {
                apiKey: 'test-api-key',
                apiGatewayId: 'test-gateway-id'
            }
        })
    }))
}));

describe('CreditcardUtilityService', () => {
    const mockCorrelationId = 'test-correlation-id';

    beforeEach(() => {
        jest.clearAllMocks();
        // Set up environment variables
        process.env.crossRegion = 'test-region';
        process.env.REGION = 'test-region';
        process.env.crossAccountRoleForCCU = 'test-role';
        process.env.ssmParamCcuApiKey = 'test-param-key';
        process.env.ssmParamCcuGatewayId = 'test-param-gateway';
        process.env.getBinRangesUrl = '12345';

        // Mock global fetch
        global.fetch = jest.fn();
    });

    describe('getBinRanges', () => {
        it('should successfully retrieve bin ranges', () => {
            const mockBinRanges = {
                binList: {
                    bin: [{
                        binStart: '400000',
                        binEnd: '499999',
                        identifier: 'TEST-BIN-001'
                    }]
                }
            };

            (global.fetch as jest.Mock).mockImplementation(() => 
                Promise.resolve({
                    status: 200,
                    json: () => Promise.resolve(mockBinRanges)
                })
            );

            // Create a new instance
            const service = new CreditcardUtilityService(mockCorrelationId);

            return service.getBinRanges().then((result: any) => {
                expect(result).toEqual(mockBinRanges.binList.bin);
                expect(global.fetch).toHaveBeenCalledWith(
                    12345,
                    expect.objectContaining({
                        method: 'GET',
                        headers: expect.objectContaining({
                            'x-api-key': 'test-api-key',
                            'x-apigw-api-id': 'test-gateway-id',
                            'x-request-id': mockCorrelationId
                        })
                    })
                );
            });
        });

        it('should throw error for non-200 response', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.resolve({
                    status: 500,
                    statusText: 'Internal Server Error'
                })
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorMessage,
                        ErrorCodes.BIN_RANGES_API_INVALID_RESPONSE_STATUS.errorCode
                    )
                );
            });
        });

        it('should throw error when API call fails', () => {
            (global.fetch as jest.Mock).mockImplementation(() =>
                Promise.reject(new Error('Network error'))
            );

            const service = new CreditcardUtilityService(mockCorrelationId);
            
            return service.getBinRanges().catch((error: ServerError) => {
                expect(error).toEqual(
                    new ServerError(
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorMessage,
                        ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR.errorCode
                    )
                );
            });
        });

        it('should throw error when cache initialization fails', () => {
            (CrossAccountAPICache as jest.Mock).mockImplementationOnce(() => {
                throw new Error('Cache initialization failed');
            });

            expect(() => new CreditcardUtilityService(mockCorrelationId)).toThrow(
                new ServerError(
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorMessage,
                    ErrorCodes.BIN_RANGES_API_UNEXPECTED_ERROR_SSM_PARAM.errorCode
                )
            );
        });
    });
});


package com.ymca.prs0.tbp.service.impl;

import com.ymca.prs0.tbp.config.properties.AuthProperties;
import com.ymca.prs0.tbp.config.properties.RetryStrategy;
import com.ymca.prs0.tbp.model.AccessTokenInfo;
import com.ymca.prs0.tbp.model.AuthCredential;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.core.env.Environment;
import org.springframework.http.MediaType;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

import java.time.Duration;

import static com.ymca.prs0.tbp.common.ApiConstants.Authorization.PING_FED_TOKEN_KEY;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class ApiAuthServiceTest {

    @Mock
    private WebClient authTokenWebClient;

    @Mock
    private Environment environment;

    @Mock
    private AuthProperties authProperties;

    @Mock
    private WebClient.Builder webClientBuilder;

    @Mock
    private WebClient.RequestBodyUriSpec requestBodyUriSpec;

    @Mock
    private WebClient.RequestHeadersSpec requestHeadersSpec;

    @Mock
    private WebClient.ResponseSpec responseSpec;

    private ApiAuthService apiAuthService;

    @BeforeEach
    void setUp() {
        apiAuthService = new ApiAuthService(authTokenWebClient, environment, authProperties);
        
        // Common setup for WebClient mock
        when(authTokenWebClient.mutate()).thenReturn(webClientBuilder);
        when(webClientBuilder.build()).thenReturn(authTokenWebClient);
        when(authTokenWebClient.post()).thenReturn(requestBodyUriSpec);
        when(requestBodyUriSpec.uri(any(String.class))).thenReturn(requestBodyUriSpec);
        when(requestBodyUriSpec.contentType(any(MediaType.class))).thenReturn(requestBodyUriSpec);
        when(requestBodyUriSpec.bodyValue(any())).thenReturn(requestHeadersSpec);
        when(requestHeadersSpec.retrieve()).thenReturn(responseSpec);
    }

    @Test
    void getToken_WhenTokenNotCached_ShouldFetchNewToken() {
        // Arrange
        final String tokenUrl = "http://test-token-url";
        
        AuthCredential authCredential = AuthCredential.builder()
            .clientId("test-client")
            .clientSecret("test-secret")
            .grantType("client_credentials")
            .build();

        AccessTokenInfo expectedToken = new AccessTokenInfo();
        expectedToken.setAccessToken("test-token");
        expectedToken.setExpiresIn(3600);

        RetryStrategy retryStrategy = new RetryStrategy(
            3,                              // maxAttempts
            0.5,                            // jitterFactor
            Duration.ofSeconds(1),          // minInterval
            Duration.ofSeconds(30)          // timeout
        );

        when(authProperties.getPingFedTokenUrl()).thenReturn(tokenUrl);
        when(authProperties.getAuthCredential(PING_FED_TOKEN_KEY)).thenReturn(authCredential);
        when(authProperties.getRetry()).thenReturn(retryStrategy);
        when(responseSpec.bodyToMono(AccessTokenInfo.class)).thenReturn(Mono.just(expectedToken));

        // Act
        AccessTokenInfo result = apiAuthService.getToken(PING_FED_TOKEN_KEY);

        // Assert
        assertNotNull(result);
        assertEquals(expectedToken.getAccessToken(), result.getAccessToken());
        assertEquals(expectedToken.getExpiresIn(), result.getExpiresIn());
        verify(authProperties).getPingFedTokenUrl();
        verify(authProperties).getAuthCredential(PING_FED_TOKEN_KEY);
    }

    @Test
    void getToken_WhenTokenCached_ShouldReturnCachedToken() {
        // Arrange
        String tokenUrl = "http://test-token-url";
        AuthCredential authCredential = AuthCredential.builder()
            .clientId("test-client")
            .clientSecret("test-secret")
            .grantType("client_credentials")
            .build();

        AccessTokenInfo expectedToken = new AccessTokenInfo();
        expectedToken.setAccessToken("cached-token");
        expectedToken.setExpiresIn(3600);

        RetryStrategy retryStrategy = new RetryStrategy(
            3,                              // maxAttempts
            0.5,                            // jitterFactor
            Duration.ofSeconds(1),          // minInterval
            Duration.ofSeconds(30)          // timeout
        );

        when(authProperties.getPingFedTokenUrl()).thenReturn(tokenUrl);
        when(authProperties.getAuthCredential(PING_FED_TOKEN_KEY)).thenReturn(authCredential);
        when(authProperties.getRetry()).thenReturn(retryStrategy);
        when(responseSpec.bodyToMono(AccessTokenInfo.class)).thenReturn(Mono.just(expectedToken));

        // First call to cache the token
        AccessTokenInfo firstResult = apiAuthService.getToken(PING_FED_TOKEN_KEY);

        // Clear invocations to verify no more calls
        clearInvocations(authTokenWebClient, authProperties);

        // Act
        AccessTokenInfo result = apiAuthService.getToken(PING_FED_TOKEN_KEY);

        // Assert
        assertNotNull(result);
        assertEquals("cached-token", result.getAccessToken());
        verifyNoInteractions(authTokenWebClient);
    }

    @Test
    void getToken_WhenErrorOccurs_ShouldThrowException() {
        // Arrange
        String tokenUrl = "http://test-token-url";
        AuthCredential authCredential = AuthCredential.builder()
            .clientId("test-client")
            .clientSecret("test-secret")
            .grantType("client_credentials")
            .build();

        RetryStrategy retryStrategy = new RetryStrategy(
            3,                              // maxAttempts
            0.5,                            // jitterFactor
            Duration.ofSeconds(1),          // minInterval
            Duration.ofSeconds(30)          // timeout
        );

        when(authProperties.getPingFedTokenUrl()).thenReturn(tokenUrl);
        when(authProperties.getAuthCredential(PING_FED_TOKEN_KEY)).thenReturn(authCredential);
        when(authProperties.getRetry()).thenReturn(retryStrategy);
        when(responseSpec.bodyToMono(AccessTokenInfo.class))
            .thenReturn(Mono.error(new RuntimeException("API Error")));

        // Act & Assert
        Exception exception = assertThrows(RuntimeException.class, () -> 
            apiAuthService.getToken(PING_FED_TOKEN_KEY)
        );
        assertTrue(exception.getMessage().contains("API Error"));
    }
}



```java
    @Test
    void getToken_WhenErrorOccurs_ShouldThrowException() {
        // Arrange
        String tokenUrl = "http://test-token-url";
        AuthCredential authCredential = AuthCredential.builder()
            .clientId("test-client")
            .clientSecret("test-secret")
            .grantType("client_credentials")
            .build();

        RetryStrategy retryStrategy = new RetryStrategy(
            3,                              // maxAttempts
            0.5,                            // jitterFactor
            Duration.ofSeconds(1),          // minInterval
            Duration.ofSeconds(30)          // timeout
        );

        // Set up the mocks
        when(authProperties.getPingFedTokenUrl()).thenReturn(tokenUrl);
        when(authProperties.getAuthCredential(PING_FED_TOKEN_KEY)).thenReturn(authCredential);
        when(authProperties.getRetry()).thenReturn(retryStrategy);

        // Mock the WebClient chain to throw an error
        when(authTokenWebClient.mutate()).thenReturn(webClientBuilder);
        when(webClientBuilder.filter(any())).thenReturn(webClientBuilder);
        when(webClientBuilder.build()).thenReturn(authTokenWebClient);
        when(authTokenWebClient.post()).thenReturn(requestBodyUriSpec);
        when(requestBodyUriSpec.uri(any(String.class))).thenReturn(requestBodyUriSpec);
        when(requestBodyUriSpec.contentType(any(MediaType.class))).thenReturn(requestBodyUriSpec);
        when(requestBodyUriSpec.headers(any(Consumer.class))).thenReturn(requestBodyUriSpec);
        when(requestBodyUriSpec.bodyValue(any())).thenReturn(requestHeadersSpec);
        when(requestHeadersSpec.retrieve()).thenReturn(responseSpec);
        when(responseSpec.bodyToMono(AccessTokenInfo.class))
            .thenReturn(Mono.error(new RuntimeException("API Error")));

        // Act & Assert
        Exception exception = assertThrows(
            RuntimeException.class, 
            () -> apiAuthService.getToken(PING_FED_TOKEN_KEY)
        );
        
        // Verify the exception message
        assertTrue(exception.getMessage().contains("API Error"));
        
        // Verify the interactions
        verify(authProperties).getPingFedTokenUrl();
        verify(authProperties).getAuthCredential(PING_FED_TOKEN_KEY);
        verify(authProperties).getRetry();
        verify(responseSpec).bodyToMono(AccessTokenInfo.class);
    }
```

The key changes are:

1. Set up the complete WebClient mock chain in the error test
2. Ensure all necessary mocks are in place before the error simulation
3. Added proper verification steps
4. Made sure the error is properly propagated through the reactive chain

The error was likely not being thrown because:
1. Either the mock chain wasn't complete, or
2. The error wasn't being properly propagated through the reactive pipeline

This fixed version should now properly test the error scenario. Let me know if you still encounter any issues!
